# Why React?



## React가 특별한 이유

- **구성적 모델이다.** (compositional model)

- **선언적 성격이다.** (declarative nature)

- **Component를 통해 Data가 흐르는 방식이다.** (The way data flows through a Component)

- **React는 실제로 JavaScript일 뿐이다.** (And that React is really just JavaScript)



React 함수를 사용하는 시기와 동일하게 생각하면 된다. 

그러나 함수가 일부 인수를 받아 값을 반환하는 대신 인수를 받아 UI를 반환한다.

```javascript
function getProfilePic (username){
    return 'https://github.com/' + username + '.png?size=200';
}

function getProfileLink (username){
    return 'https://github.com/' + username;
}

function getProfileData (username){
    return{
        pic: getProfilePic(username),
        link: getProfileLink(username)
    }
}

getProfileData('suji');
```



위 코드에서 getProfileData를 호출하면 사용자를 나타내는 객체를 얻는다.

이 함수가 데이터가 있는 객체를 반환하도록 하는 대신 Ul를 반환하도록 약간 수정해보겠다.



```react
function ProfilePic (username){
    return (<img alt={username}
            src={'https://github.com/' + username + '.png?size=200'}/>)
}

function ProfileLink (username){
    return <a href={'https://github.com/' + username}>{username}</a>
}

function Profile (username){
    return(
        <div className='profile'>
            <ProfilePic username='username' />
            <ProfileLink username='username' />
        </div>
    )
}
```





## Composition

- 정의

**간단한 기능을 결합하여 더 복잡한 기능을 구축** 

(Wikipedia/ to combine simple functions to build more complicated ones)



- 장점

Composition의 개념은 React를 굉장하고 놀랍도록 만드는데 큰 부분을 차지한다. Composition은 단순한 함수를 결합하여 복잡한 함수를 만드는 것이다. **핵심 요소( simple functions , combined to create another function)**



React는 구성의 힘을 많이 사용한다. React는 component를 사용하여 UI 조각을 만든다.



- 요약

Composition은 간단한 기능을 결합하여 더 복잡한 기능을 만들 때 발생한다.

각 기능을 하나의 작업(DOT : Do One Thing)을 수행하는 단일 블록으로 생각해라.



> 추가 자료
>
> https://www.linkedin.com/pulse/compose-me-function-composition-javascript-kevin-greene/
>
> https://hackernoon.com/javascript-functional-composition-for-every-day-use-22421ef65a10





## Imperative Code (명령형 코드)

많은 JavaScript는 명령형 코드이다. 여기서 Imperative는 명령을 표현하는 것을 말한다.

JavaScript 코드를 작성하려면 반드시 JavaScript가 수행할 작업과 수행 방법을 정확하게 알려준다.

JavaScript 명령을 하는것처럼 생각해보자.



```javascript
const people = ['Amanda', 'Farrin', 'Geoff', 'Karen', 'Richard', 'Tyler']
const excitedPeople = []

for (let i = 0; i < people.length; i++){
    excitedPeople[i] = people[i] + '!'
}
```

이 코드는 Imperative code이다. 모든 단계에서 수행할 작업을 JavaScript에 명령하고 있다.



우리는 다음과 같은 명령을 내려야한다.

- iterator의 초기값 설정 `let i = 0`
- for loop에게 중지해야할 때 알리기 `i < people.length`
- people을 현재 위치에 놓고 ! 추가하기 `people[i]+'!'`
-  다른 배열의 i번째 위치에데이터 저장하기 `excitedPeople[i]`
- i 변수를 1씩 증가시키기 `i++`



위와 같은 코드는 오래된 자동차에서 온도를 맞추는 것으로 예를 들 수 있다. 내가 원하는 온도보다 추울 경우 따뜻한 바람이 나오게 내가 조정하고, 내가 원하는 온도보다 너무 따뜻해지는 경우도 다시 찬 바람이 나오도록 모두 수동으로 내가 작업을 수행해야한다. 이는 이상적이지 않으니 개선해보자.



## Declarative Code (선언적 코드)

명령형 코드와 반대로 선언적 코드가 있다. 선언적 코드를 사용하면 최종 결과를 얻기 위해 모든 단계를 코딩하지 않는다. 대신 원하는 것을 선언하면 JavaScript가 처리한다.



위에서 작성했던 명령형 for loop code를 가져와서 선언적으로 리팩토링해보자.

명령형 코드를 사용하여 최종 결과를 얻기 위해 모든 단계를 수행했다. 하지만 실제로 우리가 원하는 최종결과물을 생각해보면 단지 이름의 배열이었다. 우리가 원하는 최종 목표는 이름은 같지만, 각 이름은 느낌표로 끝나는 배열이다.

```javascript
const people = ['Amanda', 'Farrin', 'Geoff', 'Karen', 'Richard', 'Tyler']
```



우리는 원하는 것을 얻기 위해 JavaScript의 `map()`함수를 사용하여 원하는 것을 선언한다.

```javascript
const excitedPeople = people.map(name => name + '!')
```

바로 이게 다다! 위 코드를 수행하면 아래와 같은 부분은 수행하지 않아도 된다.

- iterator object 생성
- 코드 실행이 중지되는 때를 알려주는 일
- iterator를 사용하여 `people`배열의 특정 항목에 접근
- `excitedPeople` 배열에 각각의 새로운 문자열 저장

위 모든 단계는 JavaScript의 `map()` Array 메소드에 의해 처리된다.



**React is Declarative , 리액트는 선언적이다.**



곧 React 코드를 작성해보겠지만, 어떻게 선언적인지 살펴보자

```react
<button onClick={activateTeleporter}>Activate Telepoter</button>
```

버튼에는 onClick 속성만 있다. 우리는 `addEventListener()`를 사용하여 이벤트 처리와 관련된 모든 단계로 이벤트 처리를 설정하지 않는다. 대신 버튼을 클릭할 때 `activeateTeleporter` 기능을 실행하기를 원한다.



### Declarative Code 요약

명령형 코드는 JavaScript가 각 단계를 수행하는 방법에 대해 JavaScript가 각 단계를 수행하는 방법에 대해 JavaScript에게 지시한다. 그러나 선언적 코드를 사용하여 수행하는 작업을 JavaScript에게 알려주고 JavaScript가 단계 수행을 처리하도록 한다.

**React는 원하는 코드를 작성하기 때문에 선언적이며, React는 선언된 코드를 가져와 원하는 결과를 얻기 위해 모든 JavaScript / DOM 단계를 수행해야 한다.**



> **추가자료**
>
> https://tylermcginnis.com/imperative-vs-declarative-programming/
>
> **Imperative**: C, C++, Java
>
> **Declarative**: SQL, HTML
>
> **(Can Be) Mix**: JavaScript, C#, Python
>
> 선언적 프로그래밍은 "기계의 작동 모델이 아닌 개발자의 정신 모델에 맞는 언어로 프로그래밍하는 행위"이다.



> **추가자료 / 코드 참고**
>
> **[주어진 과제]**
>
> 1. Write a function called `double` which takes in an array of numbers and returns a new array after doubling every item in that array. `double([1,2,3]) // [2,4,6]`
> 2. Write a function called `add` which takes in an array and returns the result of adding up every item in the array. `add([1,2,3]) // 6`
> 3. Using jQuery (or vanilla JavaScript), add a `click` event handler to the element which has an `id` of `btn`. When clicked, toggle (add or remove) the `highlight` class as well as change the text to `Add Highlight` or `Remove Highlight` depending on the current state of the element.
>
> ```javascript
> // Imperative code
> function double (arr) {
>   let results = []
>   for (let i = 0; i < arr.length; i++){
>     results.push(arr[i] * 2)
>   }
>   return results
> }
> 
> function add (arr) {
>   let result = 0
>   for (let i = 0; i < arr.length; i++){
>     result += arr[i]
>   }
>   return result
> }
> 
> $("#btn").click(function() {
>   $(this).toggleClass("highlight")
>   $(this).text() === 'Add Highlight'
>     ? $(this).text('Remove Highlight')
>     : $(this).text('Add Highlight')
> })
> ```
>
> ```javascript
> // Declarative code
> function double (arr) {
>   return arr.map((item) => item * 2)
> }
> 
> function add (arr) {
>   return arr.reduce((prev, current) => prev + current, 0)
> }
> 
> <Btn
>   onToggleHighlight={this.handleToggleHighlight}
>   highlight={this.state.highlight}>
>     {this.state.buttonText}
> </Btn>
> ```



> **추가자료**
>
> https://stackoverflow.com/questions/33655534/difference-between-declarative-and-imperative-in-react-js
>
> 선언의 장점은 상태를 나타내는 구현 세부사항에 얽매이지 않는다는 것이다. 애플리케이션 뷰를 일관되게 유지하는 조직 구성 요소를 위임하므로 상태에 대해서만 걱정하면 된다. 상태를 설명할 수 있으면 버그의 표면적이 대폭 줄어드는 이점이 있다. 반면, 상태 구현 방법을 위임하거나 추상화하기 때문에 상황이 발생하는 방식에 유연성이 떨어질 수 있다.





## Data-Binding in Other Frameworks

시간이 지남에 따라 앱의 상태 변경을 관리하는 인기있는 기술 중 하나는 데이터 바인딩을 사용하고 한 곳에서 데이터가 변경될 때 변경 사항이 앱의 다른 위치에 자동으로 반영된다

해당 데이터가 있는 앱의 모든 부분도 데이터를 변경할 수 있다.

그러나 앱이 커짐에 따라 이 기술로 인해 한 곳은 자동으로 암시적으로 나머지 앱에 영향을 준다.

React는 명시적인 방법으로 데이터를 전달한다. 상태 변경을 쉽게 추적할 수 있는 구성 요소, 앱의 다른 위치에 어떻게 영향을 미치는지 이를 단방향 데이터 흐름이라고 한다.

데이터는 부모 요소에서 자식으로 한 방향으로 흐른다.



Angular나 Ember와 같은 프론트 엔드 프레임워크는 양방향 데이터 바인딩을 사용한다. 양방향 데이터 바인딩에서 데이터는 업데이트되는 위치에 관계없이 앱 전체에서 동기화 상태를 유지한다. 모델이 데이터를 변경하면 뷰에서 데이터가 업데이트 된다. 또는 사용자가 뷰에서 데이터를 변경하면 데이터가 모델에서 업데이트 된다. 양방향 데이터 바인딩은 매우 강력하지만 응용 프로그램에서 데이터가 실제로 업데이트되는 위치를 추리하고 파악하기가 더 어려워 질 수 있다.



> 추가자료
>
> - [Angular's two-way data binding](https://angular.io/guide/template-syntax#two-way)
> - [Ember's two-way data binding](https://guides.emberjs.com/v2.13.0/object-model/bindings/)



### React's Data-flow

데이터는 React의 단방향 데이터 흐름과 다르게 이동한다. React에서 데이터는 상위 컴포넌트에서 하위 컴포넌트로 흐른다.

![](https://video.udacity-data.com/topher/2018/March/5ab9e2e5_nd019-c1-l1-reacts-data-flow/nd019-c1-l1-reacts-data-flow.png)

위 이미지에는 두 가지 구성 요소(부모 구성 요소, 자식 구성 요소)가 있다.



데이터는 상위 구성 요소에 있으며 하위 구성 요소로 전달된다. 데이터가 상위 구성 요소에 상주하더라도 상위 및 하위 구성 요소 모두 데이터를 사용할 수 있다. 그러나 데이터를 업데이트해야하는 경우 상위 구성 요소만 업데이트를 수행해야한다. 하위 구성요소가 데이터를 변경해야하는 경우 업데이트 된 데이터를 실제 변경이 수행 될 상위 구성요소로 보낸다. 상위 컴포넌트에서 `_is_`를 변경하면 하위 컴포넌트에 데이터가 전달된다. (방금 업데이트 된 것이다.)



이제는 추가 작업처럼 보일 수 있지만 데이터가 한 방향으로 흐르고 데이터가 수정되는 위치가 있으면 응용 프로그램의 작동 방식을 훨씬 쉽게 이해할 수 있다.



### React에서 Data Flow 요약

React에서 데이터는 부모에서 자식으로 한 방향으로만 흐른다. 형제 자식 구성 요소간에 데이터가 공유되는 경우 데이터는 부모 구성 요소에 저장되어 필요한 자식 구성 요소 모두에 전달되어야 한다.

