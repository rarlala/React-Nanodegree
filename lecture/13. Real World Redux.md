# Real World Redux



## Introduction

이 시점까지 간단한 Todo's App을 구축하여 Redux의 모든 기능을 다루었다. 이 프로젝트는 학습 목적으로는 훌륭했지만, 초보적인 단계이다. 

이제 실제 프로젝트의 복잡성을 경험해보자. 지금까지 배운 모든 주제인 Redux-React를 React-Redux 바인딩 및 미들웨어를 사용하여 보다 복잡한 실제 응용 프로그램을 구축할 것이다.



**우리는 이제 최소한의 트위터 클론을 구축할 것이다.** 

예시 사이트 : https://tylermcginnis.com/projects/redux-twitter/



- 시작을 위해 초기 코드 clone을 받자. [clone 사이트](https://classroom.udacity.com/nanodegrees/nd019/parts/7dab5516-d1ae-45d3-b8f8-d782b5534caf/modules/221d27be-a830-49a3-9803-9aa4a114489c/lessons/f126db7d-157a-4b30-90de-17bd8b07208b/concepts/9371c8b3-8df8-4fc8-a511-3b21ae438261)

- package를 설치받고, 개발 서버를 시작하자.

```
$ npm i
$ npm start
```

(이 시점에서 앱을 실행하면, Starter Code라고 말하는 화면이 표시되어야 한다.)



프로젝트 내부를 보면 `utils` 폴더에 `_DATA.js`가 있다. 이는 우리의 가짜 데이터베이스를 나타낸다. 가짜 데이터들과 데이터에 접근할 수 있는 몇가지 방법이 있다. 

하지만 이 파일과 직접 상호 작용하지는 않고 `api.js` 파일을 통해 데이터베이스와 상호작용한다. 이것은 주어진 API 파일과 같다. 서버와 상호 작용하고, 데이터 베이스와 상호 작용하기 위해 api.js를 사용할 것이다. 

api.js의 `getInitialData()`는 애플리케이션의 초기 데이터를 가져온다. `saveLikeToggle()`를 호출하여 트윗을 저장할 수 있다.

본격적인 서버와 데이터베이스는 아니지만 방법을 학습한다.

`helper.js`는 일종의 설명이다. 날짜 형식을 지정하는 방법, 트윗의 서식을 지정한 것이다.

다음 학습에서는 애플리케이션의 초기 데이터를 가져오는 방법을 학습해보자.





## Project Walkthrough

### Project Walkthrough

React와 Redux에 대한 이해를 강화하기 위해 프로젝트 연습을 하겠습니다. 우리가 건설할 프로젝트를 "Chirper"라고합니다. 이 간단한 Twitter 복제본을 구축하면 응용 프로그램 상태의 예측 가능성을 향상시키는 데 도움이 됩니다. store getting, listening 및 update에 대한 엄격한 규칙 설정; Redux 내부에 어떤 상태가 있어야하고 React 구성 요소 내에 어떤 상태가 있어야하는지 식별합니다.

대부분의 경우와 마찬가지로 성공적인 결과를 얻으려면 하나 이상의 올바른 방법이 있습니다. 우리는 React / Redux 프로젝트를 구축하는 한 가지 접근법에 대해 논의할 것입니다. 우리는 당신에게 맞는 접근법을 생각해내는 것이 좋습니다. 선택한 접근 방식에 관계없이 코딩을 시작하기 전에 항상 프로젝트 아키텍처를 계획해야합니다.



### The Importance of Planning Your Project

많은 개발자들이 앱의 아키텍처가 정확히 무엇인지 파악하기 전에 코드를 작성하는 실수를 저지릅니다. 이러한 접근 방식은 디버깅에 엄청난 시간을 소비하고 코드를 재구성하며 때로는 완전히 다시 시작합니다!

코드를 시작하기 전에 프로젝트를 계획하면 나중에 많은 시간을 절약 할 수 있습니다.

Chirper 프로젝트 연습에서는 계획 단계와 프로젝트의 코딩 단계를 살펴 봅니다.



### Planning Your React/Redux App's Architecture

계획 단계에서는 앱 아키텍처를 만드는 데 도움이되는 4단계를 거칩니다. 이는 종종 가장 까다로운 부분입니다.

#### A Guide for the Planning Stages of Your Project

1. 각 뷰의 모양 확인

2. 각 뷰를 구성 요소 계층으로 나누기
3. 앱에서 어떤 이벤트가 발생했는지 확인
4. 저장소에 어떤 데이터가 있는지 확인



### Coding in Stages

프로젝트 개발의 각 단계를 세분화하면서 함께 프로젝트를 구축 할 것입니다. 우리가 할 첫 번째 일은 최종 프로젝트가 가져야 할 다양한 견해를 살펴 보는 것입니다. 

뛰어 들자!





## Planning Stage: Steps 1&2 - Break Down Views and Components

### Step 1 - Identify Each View

앱에서 각 뷰의 모양과 기능을 결정해야합니다. 가장 좋은 방법 중 하나는 앱에 대한 각 뷰를 종이에 그려서 각 페이지에 어떤 정보와 데이터를 계획하고 있는지 파악하는 것입니다.

종이와 연필 대신 좀 더 디지털화하고 모형을 만들기 위해 [소프트웨어](https://codingsans.com/blog/mockup-tools)를 사용할 수 있습니다. 프로젝트 사양이 제공된 경우 모의 객체와 비교하여 필요한 기능이 모두 있는지 확인하십시오.

이 프로젝트에서는 모의 대신 빌드 할 앱의 스크린샷을 사용합니다.



#### View for the Dashboard Page

대시보드 보기를 살펴 보자.

![](https://video.udacity-data.com/topher/2018/March/5abd5601_nd019-redux-l7-views-01-dashboard/nd019-redux-l7-views-01-dashboard.jpg)

##### Dashboard View Requirements

- `/` 홈 경로에 있습니다.
- 가장 최근에 추가된 트윗을 아래에서 가장 오래된 트윗으로 정렬합니다.
- 각 트윗에는 다음이 표시됩니다.
  - 저자
  - 타임 스탬프
  - 작성자가 답장을 보낸 사람
  - 트윗의 텍스트
  - 답글 버튼-답글 수 (0보다 큰 경우) 
  - 좋아요 버튼-좋아요 수가있는 경우 (0보다 큰 경우)



#### View for the Tweet Page

![](https://video.udacity-data.com/topher/2018/March/5abd5636_nd019-redux-l7-views-02-tweet/nd019-redux-l7-views-02-tweet.jpg)

##### Tweet Page View Requirements

- `/tweet/:id`에 있습니다.
- 개별 트윗을 보여줍니다
  - 저자
  - 타임 스탬프
  - 답글 버튼-답글 수 (0보다 큰 경우)
  - 좋아요 버튼-좋아요 수가있는 경우 (0보다 큰 경우)
- 답장 양식이 있습니다
- 모든 답글을 표시합니다



#### View for Creating a New Tweet

![](https://video.udacity-data.com/topher/2018/March/5abd5660_nd019-redux-l7-views-03-new-tweet/nd019-redux-l7-views-03-new-tweet.jpg)

##### The New Tweet View Requirements

- `/new`에 있습니다.
- 새 트윗을 추가 할 수 있는 텍스트 상자가 있습니다.



#### View Recap

앱에서 필요한 3가지 뷰는 다음과 같습니다.

- Dashboard
- Tweet
- New Tweet

우리는 이제 우리가 무엇을 구축하려고하는지 명확하게 이해했으며 우리의 견해가 제공된 모든 요구 사항을 충족한다고 확신 할 수 있습니다.

이제 2단계로 넘어가서 앱의 개념적 뼈대를 만듭니다.



### Step 2: Break Each View Into a Hierarchy of Components

이 단계에서는 두 가지 작업을 수행합니다.

- 모든 구성 요소 주위에 상자를 그립니다

- 컴포넌트를 계층 구조로 배열

> 무언가가 React 앱의 구성 요소인지 어떻게 알 수 있습니까?
>
> - 사고의 생각 문서에 따르면, **단일 책임 원칙**은 훌륭한 전략입니다!

> [React 문서에서 생각하기](https://reactjs.org/docs/thinking-in-react.html#step-1-break-the-ui-into-a-component-hierarchy)에 따르면 : 구성 요소는 이상적으로 한 가지만 수행해야합니다. 결국 자라면 더 작은 하위 구성 요소로 분해되어야합니다.



> Which of the following are true?
>
> - Components let you split the UI into independent, reusable chunks.
> - Each view typically has a component that represents that view.
> - Presentational Components don't know where their data comes from.
> - Components that are connected to the store are called "containers".



모든 구성 요소 주위에 상자를 그리고 모든 이름을 지정하여 시작하겠습니다. 세 가지 견해가 있습니다.

- Dashboard
- Tweet
- New Tweet

대시보드 보기부터 시작하겠습니다.



### Components for the Dashboard View

![](https://video.udacity-data.com/topher/2018/March/5abd56d2_nd019-redux-l7-components-01-dashboard/nd019-redux-l7-components-01-dashboard.png)

이 견해를 다음과 같은 React Components로 나누었습니다.

- App - 프로젝트의 전체 컨테이너
- Navigation - 탐색을 표시합니다
- Tweets List - 트윗 전체 목록에 대한 책임 
- Tweets - 단일 트윗의 내용을 표시하는 책임



### Components for the Tweet View

![](https://video.udacity-data.com/topher/2018/March/5abd56f5_nd019-redux-l7-components-02-tweet/nd019-redux-l7-components-02-tweet.png)

이 견해를 다음과 같은 React Components로 나누었습니다.

- App -프로젝트의 전체 컨테이너 
- Navigation - Navigation을 표시합니다 
- Tweet Container - tweets 목록을 표시 
- Tweet - 단일 Tweet의 내용을 표시합니다 
- New Tweet - 새 Tweet을 만들 양식을 표시합니다 (답글).



### Components for the New Tweet View

![](https://video.udacity-data.com/topher/2018/March/5abd570f_nd019-redux-l7-components-03-new-tweet/nd019-redux-l7-components-03-new-tweet.png)

이 견해를 다음과 같은 React Components로 나누었습니다.

- App -프로젝트의 전체 컨테이너 
- Navigation - Navigation을 표시합니다 
- New Tweet - 새 Tweet을 만들 양식을 표시합니다 (답글).



### All Components

따라서 응용 프로그램에는 다음 구성 요소가 있습니다

- App
- Navigation
- Tweets List
- Tweet Container
- Tweet
- New Tweet

이 component 계층은 다른 component 내에서 사용할 component를 알려줍니다. 그것은 우리에게 우리 앱의 뼈대를 제공합니다. 이들은 모두 presentational component입니다. 현재 어떤 component가 컨테이너로 업그레이드되는지는 중요하지않습니다. store를 구축하기 시작하면 store에서 데이터를 가져와서 데이터가 필요한 프리젠테이션 component로 전달하는 컨테이너 component인 추가 component를 작성합니다.

지금까지 우리는 Redux에 특별한 작업을 수행하지 않았습니다. 위의 모든 단계는 Redux를 사용하지 않는 React 애플리케이션에 적용가능하고 유용합니다.

Redux는 앱의 모양이나 사용하는 구성 요소에 신경 쓰지 않습니다. 대신 응용 프로그램의 상태를 예측 가능한 방식으로 관리할 수 있는 방법을 제공합니다. state에 대해 이야기 할 때 앱 내부의 모든 종류의 데이터뿐만 아니라 앱의 이벤트에 따라 변경될 수있는 데이터에 대해서도 이야기하고 있습니다.

3단계로 넘어가서 이 앱의 데이터에 대해 생각해봅시다.





### Step 3: Determine Events In The App

#### Determine What Events Happen in the App

우리는 각 component에서 일어나는 일을 살펴볼 필요가 있습니다. 앱 또는 사용자가 데이터에서 수행하는 작업을 결정합시다. 데이터가 설정, 수정 또는 삭제됩니까? ... 그런 다음 해당 이벤트를 추적하기위한 조치가 필요합니다!

action을 <u>밑줄</u>로 표시하고 data를 **굵게** 표시하겠습니다.



#### Tweets List Component

![](https://video.udacity-data.com/topher/2018/March/5abd5744_nd019-redux-l7-store-01-tweet-list/nd019-redux-l7-store-01-tweet-list.png)

Tweets List Component의 경우, 우리가 볼 수 있는 유일한 정보는 모든 트윗 목록을 가져와야 한다는 것입니다. 따라서이 component의 경우 다음을 수행해야합니다.

- <u>get</u> the **tweets**

따라서 이벤트의 작업 유형은 아마도 `GET_LIST_OF_TWEETS` 또는 `GET_DATA`와 같습니다.



#### Tweet Component

![](https://video.udacity-data.com/topher/2018/March/5abd5771_nd019-redux-l7-store-02-tweet/nd019-redux-l7-store-02-tweet.png)

- 트윗 목록에서 특정 **tweets**을 <u>받습니다.</u> 
- **authedUser (현재 로그인 한 사용자)**를 <u>얻으므로</u> 각 **tweet**에서 좋아요를 <u>toggle</u>할 수 있습니다.
- 우리는 **authedUser**를 <u>얻으므로</u> 사용자는 tweet에 <u>답할 수 있습니다</u>.



#### Tweet Container Component

![](https://video.udacity-data.com/topher/2018/March/5abd578d_nd019-redux-l7-store-03-tweet-container/nd019-redux-l7-store-03-tweet-container.png)

- **tweets** 목록에서 특정 트윗을 <u>받습니다</u>.

- **tweets** 목록에서 특정 트윗에 대한 회신을 <u>받습니다</u>.



#### New Tweet Component

![](https://video.udacity-data.com/topher/2018/March/5abd57a6_nd019-redux-l7-store-04-new-tweet/nd019-redux-l7-store-04-new-tweet.png)

- 사용자가 새 **tweet**을 만들 수 있도록 **authedUser**를 <u>얻습니다</u>.
- **새 tweet의 텍스트**를 <u>설정</u>했습니다.



4단계로 넘어 가서, 위의 데이터 중 어떤 것이 상점에 존재할지 결정합니다.





### Step 4: Data and Store

#### Store에 어떤 데이터가 있는지 확인

Redux (및 react-redux 바인딩!)가 해결해야 할 주요 문제는 다음과 같습니다.

- 전체 component tree를 통한 props의 전파. 
- 앱에서 state의 일관성 및 예측 가능성 보장



Redux의 작성자인 Dan Abramov에 따르면, store 또는 React 컴포넌트에 데이터를 저장할지 여부를 결정하기 위해 다음 원칙을 따라야합니다.

> *"Use Redux for state that matters globally or is mutated in complex ways… The rule of thumb is: do whatever is less awkward."*
>
> **"전 세계적으로 중요하거나 복잡한 방식으로 변형된 상태에는 Redux를 사용하십시오. 경험상 규칙은 덜 어색한 것을 수행하는 것입니다."**

Take a look at [Organizing State](https://redux.js.org/faq/organizing-state) and [How to choose between Redux's store and React's state?](https://github.com/reactjs/redux/issues/1287) for further information about this.



3단계의 각 데이터 조각에 대해 여러 component에서 사용하는지 또는 복잡한 방식으로 변경했는지 확인하십시오.

> 새로운 트윗의 텍스트 사용 : New Tweet Component

이 데이터 조각은 여러 구성 요소에서 사용되지 않으며 복잡한 방식으로 변경되지 않습니다. 즉, store에 상주하는 앱 state 대신 component state에 대한 훌륭한 후보임을 의미합니다.

> 사용되는 트윗 :  Dashboard Component, Tweet Page Component, Tweet Component



Tweet Page Component에는 답글 트윗을 표시해야합니다. `_Data.js` 파일에서 시작 코드를 살펴 보겠습니다. 트윗이 데이터베이스에 저장되는 방식입니다.

```
let tweets = {
  tweetId: {
    id: tweetId,
    text: tweetText,
    author: userId,
    timestamp: timestamp,
    likes: [userId1, userId2],
    replies: [tweetId1, tweetId2],
    replyingTo: tweetId_OR_null
  }
};
```

답글 트윗을 받으려면 모든 트윗 목록에서 특정 ID를 가진 트윗을 가져와 해당 `replies` 속성에 액세스 할 수 있습니다.

Dashboard Component에서 현재 트윗 목록에 액세스해야합니다. Dashboard Component는 표시해야하는 트윗의 ID를 알고 있으면 해당 ID를 Tweet Component에 전달하면 해당 트윗을 렌더링 할 수 있습니다.

Tweet Component의 현재 트윗 목록에서 특정 ID를 가진 트윗을 선택해야합니다.

즉, 트윗을 store에 저장하고 Tweet Page Component, Dashboard Component 및 Tweet Component를 containers(`connect` 기능을 통해 store에 접근 할 수 있는 Component)로 만들 수 있습니다.

누군가가 트윗을 좋아하는 경우 해당 데이터가 변경되 자마자 해당 데이터를 사용하는 모든 구성 요소가 업데이트됩니다.

![](https://video.udacity-data.com/topher/2018/March/5abd64fe_1-2/1-2.png)

각 트윗에는 author's name과  author's avatar가 포함되어 있습니다. 상태를 모델링 할 수 있는 한 가지 방법은 다음과 같습니다.

```
tweets: {
  tweetId: {tweetId, authorId, authorName, authorAvatar, timestamp, text, likes, replies, replyingTo},
  tweetId: {tweetId, authorId, authorName, authorAvatar, timestamp, text, likes, replies, replyingTo}
}
```

이러한 방식으로 상태를 모델링하는 것은 잘못된 것은 아니지만 나중에 특정 작성자가 작성한 트윗을 찾을 수 있도록 애플리케이션 기능을 확장하려는 경우 불편합니다.

또한 이러한 데이터 저장 방식은 두 가지 유형의 객체를 혼합합니다.

- tweets data
- user data

이것은 우리의 state를 정상화하라는 권고에 위배됩니다. [Redux 문서](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape)에 따르면 state 정규화 원칙은 다음과 같습니다.

- 각 유형의 데이터는 state에서 자체 "table"을 얻습니다.
- 각 "데이터 테이블"은 항목의 ID를 키로, 항목 자체를 값으로 사용하여 개별 항목을 객체에 저장해야합니다.
- 개별 품목에 대한 언급은 품목 ID를 저장하여 수행해야합니다.
- 순서를 나타내기 위해 ID 배열을 사용해야합니다.

우리의 응용 프로그램에서 정규화 된 상태는 다음과 같습니다.

```
{
  tweets: {
    tweet: { tweetId, authorId, timestamp, text, likes, replies, replyingTo},
    tweet: { tweetId, authorId, timestamp, text, likes, replies, replyingTo}
  },
  users: {
    user: {userId, userName, avatar, tweetsArray},
    user: {userId, userName, avatar, tweetsArray}
  }
}
```



이 시점에서 우리의 상점 :

![](https://video.udacity-data.com/topher/2018/March/5abd6595_1/1.png)

계속해서 데이터를 살펴 보겠습니다.

*authedUser* *Used by*: Tweet Component, New Tweet Component

각 Tweet Component는 로그인 한 사용자 특정 트윗을 좋아했는지 표시해야합니다. 그렇게하려면 로그인 한 사용자가 누구인지 알아야합니다. 2단계의 구성요소 계층을 살펴보면 Tweet 구성요소가 여러 구성요소에서 사용됨을 알 수 있습니다. 따라서 이 구성 요소를 컨테이너로 업그레이드하여 상점에서 인증된 사용자 데이터에 접근하여 하트를 표시할지 여부를 확인할 수 있습니다.

또한 모든 새 트윗에 대해 트윗 작성자 (authedUser)가 누구인지 기록해야합니다. 상태를 저장하는 React 방식은 상태를 가장 상위 구성 요소에 넣은 다음 이를 필요한 모든 하위 항목으로 전달하는 것입니다. 이 앱에서 이는 앱 컴포넌트에 저장하는 것을 의미합니다.

이를 수행하는 한 가지 방법은 authedUser를 앱 구성 요소에 저장한 다음 액세스 해야하는 구성요소로 전달하는 것입니다. 이는 작동하는동안 불편합니다. 인증된 사용자를 store에 저장한 후 상점에 대한 트윗 구성 요소 액세스를 제공하는 것이 훨씬 더 간단합니다. 새 트윗 구성 요소는 새 트윗의 텍스트와 새 트윗을 저장하기 위해 매개 변수로 회신하는 트윗의 ID로 조치를 전달할 수 있습니다.

트윗 저장은 비동기 작업이며 redux thunks를 사용하여 이를 수행할 수 있습니다. thunks는 우리에게 상점에 대한 액세스 권한을 부여하여 다음과 같은 action creator를 가질 수 있습니다.

```react
function handleAddTweet(text, replyingTo) {
  return (dispatch, getState) => {
    const { authedUser } = getState();

    return saveTweetToDatabase({
      text,
      author: authedUser,
      replyingTo
    }).then(tweet => dispatch(addTweet(tweet)));
  };
}
```

일반적으로 action creator로부터 store에 접근하는 것은 [반 패턴](https://stackoverflow.com/questions/35667249/accessing-redux-state-in-an-action-creator/35674575#35674575)으로 간주됩니다. 댄 아브라모프 (Dan Abramov)는 이를 수용할 수 있는 몇 가지 사용 사례는 다음과 같다고 말합니다.

> 요청하기 전에 캐시된 데이터를 확인하거나 인증 여부 (즉, 조건부 디스패치 수행)를 확인합니다.

authedUser 데이터를 스토어에 보관하려는 또 다른 이유는 로그인 및 로그아웃 기능을 포함하도록 애플리케이션을 확장하면 이 기능을 Redux로 쉽게 관리 할 수 있기 때문입니다.

새 트윗 구성요소는 인증된 사용자 상태에 액세스 할 필요는 없지만 리듀서에게 새 트윗이 작성되었음을 알리기 위해 조치를 전달할 수 있어야합니다. 디스패치 메소드에 액세스하려면 구성요소를 상점에 연결해야합니다. 즉, 컨테이너여야합니다. 따라서 트윗 구성 요소와 새 트윗 구성 요소가 모두 컨테이너로 업그레이드됩니다.



![](https://video.udacity-data.com/topher/2018/March/5abd5886_1/1.png)

우리는 store를 만들었습니다! store을 만드는 동안 container로 업그레이드 할 component도 결정했기 때문에 이제는 뼈대 앱이 더욱 완벽해졌습니다.

우리는 이제 코딩을 시작하기에 좋은 시점에 있습니다. 우리는 한눈에 살펴보고 골격의 세부사항을 그 길을 따라 채울 것입니다.