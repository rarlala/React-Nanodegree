# Real World Redux



## Introduction

이 시점까지 간단한 Todo's App을 구축하여 Redux의 모든 기능을 다루었다. 이 프로젝트는 학습 목적으로는 훌륭했지만, 초보적인 단계이다. 

이제 실제 프로젝트의 복잡성을 경험해보자. 지금까지 배운 모든 주제인 Redux-React를 React-Redux 바인딩 및 미들웨어를 사용하여 보다 복잡한 실제 응용 프로그램을 구축할 것이다.



**우리는 이제 최소한의 트위터 클론을 구축할 것이다.** 

예시 사이트 : https://tylermcginnis.com/projects/redux-twitter/



- 시작을 위해 초기 코드 clone을 받자. [clone 사이트](https://classroom.udacity.com/nanodegrees/nd019/parts/7dab5516-d1ae-45d3-b8f8-d782b5534caf/modules/221d27be-a830-49a3-9803-9aa4a114489c/lessons/f126db7d-157a-4b30-90de-17bd8b07208b/concepts/9371c8b3-8df8-4fc8-a511-3b21ae438261)

- package를 설치받고, 개발 서버를 시작하자.

```
$ npm i
$ npm start
```

(이 시점에서 앱을 실행하면, Starter Code라고 말하는 화면이 표시되어야 한다.)



프로젝트 내부를 보면 `utils` 폴더에 `_DATA.js`가 있다. 이는 우리의 가짜 데이터베이스를 나타낸다. 가짜 데이터들과 데이터에 접근할 수 있는 몇가지 방법이 있다. 

하지만 이 파일과 직접 상호 작용하지는 않고 `api.js` 파일을 통해 데이터베이스와 상호작용한다. 이것은 주어진 API 파일과 같다. 서버와 상호 작용하고, 데이터 베이스와 상호 작용하기 위해 api.js를 사용할 것이다. 

api.js의 `getInitialData()`는 애플리케이션의 초기 데이터를 가져온다. `saveLikeToggle()`를 호출하여 트윗을 저장할 수 있다.

본격적인 서버와 데이터베이스는 아니지만 방법을 학습한다.

`helper.js`는 일종의 설명이다. 날짜 형식을 지정하는 방법, 트윗의 서식을 지정한 것이다.

다음 학습에서는 애플리케이션의 초기 데이터를 가져오는 방법을 학습해보자.





## Project Walkthrough

### Project Walkthrough

React와 Redux에 대한 이해를 강화하기 위해 프로젝트 연습을 하겠습니다. 우리가 건설할 프로젝트를 "Chirper"라고합니다. 이 간단한 Twitter 복제본을 구축하면 응용 프로그램 상태의 예측 가능성을 향상시키는 데 도움이 됩니다. store getting, listening 및 update에 대한 엄격한 규칙 설정; Redux 내부에 어떤 상태가 있어야하고 React 구성 요소 내에 어떤 상태가 있어야하는지 식별합니다.

대부분의 경우와 마찬가지로 성공적인 결과를 얻으려면 하나 이상의 올바른 방법이 있습니다. 우리는 React / Redux 프로젝트를 구축하는 한 가지 접근법에 대해 논의할 것입니다. 우리는 당신에게 맞는 접근법을 생각해내는 것이 좋습니다. 선택한 접근 방식에 관계없이 코딩을 시작하기 전에 항상 프로젝트 아키텍처를 계획해야합니다.



### The Importance of Planning Your Project

많은 개발자들이 앱의 아키텍처가 정확히 무엇인지 파악하기 전에 코드를 작성하는 실수를 저지릅니다. 이러한 접근 방식은 디버깅에 엄청난 시간을 소비하고 코드를 재구성하며 때로는 완전히 다시 시작합니다!

코드를 시작하기 전에 프로젝트를 계획하면 나중에 많은 시간을 절약 할 수 있습니다.

Chirper 프로젝트 연습에서는 계획 단계와 프로젝트의 코딩 단계를 살펴 봅니다.



### Planning Your React/Redux App's Architecture

계획 단계에서는 앱 아키텍처를 만드는 데 도움이되는 4단계를 거칩니다. 이는 종종 가장 까다로운 부분입니다.

#### A Guide for the Planning Stages of Your Project

1. 각 뷰의 모양 확인

2. 각 뷰를 구성 요소 계층으로 나누기
3. 앱에서 어떤 이벤트가 발생했는지 확인
4. 저장소에 어떤 데이터가 있는지 확인



### Coding in Stages

프로젝트 개발의 각 단계를 세분화하면서 함께 프로젝트를 구축 할 것입니다. 우리가 할 첫 번째 일은 최종 프로젝트가 가져야 할 다양한 견해를 살펴 보는 것입니다. 

뛰어 들자!





## Planning Stage: Steps 1&2 - Break Down Views and Components

### Step 1 - Identify Each View

앱에서 각 뷰의 모양과 기능을 결정해야합니다. 가장 좋은 방법 중 하나는 앱에 대한 각 뷰를 종이에 그려서 각 페이지에 어떤 정보와 데이터를 계획하고 있는지 파악하는 것입니다.

종이와 연필 대신 좀 더 디지털화하고 모형을 만들기 위해 [소프트웨어](https://codingsans.com/blog/mockup-tools)를 사용할 수 있습니다. 프로젝트 사양이 제공된 경우 모의 객체와 비교하여 필요한 기능이 모두 있는지 확인하십시오.

이 프로젝트에서는 모의 대신 빌드 할 앱의 스크린샷을 사용합니다.



#### View for the Dashboard Page

대시보드 보기를 살펴 보자.

![](https://video.udacity-data.com/topher/2018/March/5abd5601_nd019-redux-l7-views-01-dashboard/nd019-redux-l7-views-01-dashboard.jpg)

##### Dashboard View Requirements

- `/` 홈 경로에 있습니다.
- 가장 최근에 추가된 트윗을 아래에서 가장 오래된 트윗으로 정렬합니다.
- 각 트윗에는 다음이 표시됩니다.
  - 저자
  - 타임 스탬프
  - 작성자가 답장을 보낸 사람
  - 트윗의 텍스트
  - 답글 버튼-답글 수 (0보다 큰 경우) 
  - 좋아요 버튼-좋아요 수가있는 경우 (0보다 큰 경우)



#### View for the Tweet Page

![](https://video.udacity-data.com/topher/2018/March/5abd5636_nd019-redux-l7-views-02-tweet/nd019-redux-l7-views-02-tweet.jpg)

##### Tweet Page View Requirements

- `/tweet/:id`에 있습니다.
- 개별 트윗을 보여줍니다
  - 저자
  - 타임 스탬프
  - 답글 버튼-답글 수 (0보다 큰 경우)
  - 좋아요 버튼-좋아요 수가있는 경우 (0보다 큰 경우)
- 답장 양식이 있습니다
- 모든 답글을 표시합니다



#### View for Creating a New Tweet

![](https://video.udacity-data.com/topher/2018/March/5abd5660_nd019-redux-l7-views-03-new-tweet/nd019-redux-l7-views-03-new-tweet.jpg)

##### The New Tweet View Requirements

- `/new`에 있습니다.
- 새 트윗을 추가 할 수 있는 텍스트 상자가 있습니다.



#### View Recap

앱에서 필요한 3가지 뷰는 다음과 같습니다.

- Dashboard
- Tweet
- New Tweet

우리는 이제 우리가 무엇을 구축하려고하는지 명확하게 이해했으며 우리의 견해가 제공된 모든 요구 사항을 충족한다고 확신 할 수 있습니다.

이제 2단계로 넘어가서 앱의 개념적 뼈대를 만듭니다.



### Step 2: Break Each View Into a Hierarchy of Components

이 단계에서는 두 가지 작업을 수행합니다.

- 모든 구성 요소 주위에 상자를 그립니다

- 컴포넌트를 계층 구조로 배열

> 무언가가 React 앱의 구성 요소인지 어떻게 알 수 있습니까?
>
> - 사고의 생각 문서에 따르면, **단일 책임 원칙**은 훌륭한 전략입니다!

> [React 문서에서 생각하기](https://reactjs.org/docs/thinking-in-react.html#step-1-break-the-ui-into-a-component-hierarchy)에 따르면 : 구성 요소는 이상적으로 한 가지만 수행해야합니다. 결국 자라면 더 작은 하위 구성 요소로 분해되어야합니다.



> Which of the following are true?
>
> - Components let you split the UI into independent, reusable chunks.
> - Each view typically has a component that represents that view.
> - Presentational Components don't know where their data comes from.
> - Components that are connected to the store are called "containers".



모든 구성 요소 주위에 상자를 그리고 모든 이름을 지정하여 시작하겠습니다. 세 가지 견해가 있습니다.

- Dashboard
- Tweet
- New Tweet

대시보드 보기부터 시작하겠습니다.



### Components for the Dashboard View

![](https://video.udacity-data.com/topher/2018/March/5abd56d2_nd019-redux-l7-components-01-dashboard/nd019-redux-l7-components-01-dashboard.png)

이 견해를 다음과 같은 React Components로 나누었습니다.

- App - 프로젝트의 전체 컨테이너
- Navigation - 탐색을 표시합니다
- Tweets List - 트윗 전체 목록에 대한 책임 
- Tweets - 단일 트윗의 내용을 표시하는 책임



### Components for the Tweet View

![](https://video.udacity-data.com/topher/2018/March/5abd56f5_nd019-redux-l7-components-02-tweet/nd019-redux-l7-components-02-tweet.png)

이 견해를 다음과 같은 React Components로 나누었습니다.

- App -프로젝트의 전체 컨테이너 
- Navigation - Navigation을 표시합니다 
- Tweet Container - tweets 목록을 표시 
- Tweet - 단일 Tweet의 내용을 표시합니다 
- New Tweet - 새 Tweet을 만들 양식을 표시합니다 (답글).



### Components for the New Tweet View

![](https://video.udacity-data.com/topher/2018/March/5abd570f_nd019-redux-l7-components-03-new-tweet/nd019-redux-l7-components-03-new-tweet.png)

이 견해를 다음과 같은 React Components로 나누었습니다.

- App -프로젝트의 전체 컨테이너 
- Navigation - Navigation을 표시합니다 
- New Tweet - 새 Tweet을 만들 양식을 표시합니다 (답글).



### All Components

따라서 응용 프로그램에는 다음 구성 요소가 있습니다

- App
- Navigation
- Tweets List
- Tweet Container
- Tweet
- New Tweet

이 component 계층은 다른 component 내에서 사용할 component를 알려줍니다. 그것은 우리에게 우리 앱의 뼈대를 제공합니다. 이들은 모두 presentational component입니다. 현재 어떤 component가 컨테이너로 업그레이드되는지는 중요하지않습니다. store를 구축하기 시작하면 store에서 데이터를 가져와서 데이터가 필요한 프리젠테이션 component로 전달하는 컨테이너 component인 추가 component를 작성합니다.

지금까지 우리는 Redux에 특별한 작업을 수행하지 않았습니다. 위의 모든 단계는 Redux를 사용하지 않는 React 애플리케이션에 적용가능하고 유용합니다.

Redux는 앱의 모양이나 사용하는 구성 요소에 신경 쓰지 않습니다. 대신 응용 프로그램의 상태를 예측 가능한 방식으로 관리할 수 있는 방법을 제공합니다. state에 대해 이야기 할 때 앱 내부의 모든 종류의 데이터뿐만 아니라 앱의 이벤트에 따라 변경될 수있는 데이터에 대해서도 이야기하고 있습니다.

3단계로 넘어가서 이 앱의 데이터에 대해 생각해봅시다.





### Step 3: Determine Events In The App

#### Determine What Events Happen in the App

우리는 각 component에서 일어나는 일을 살펴볼 필요가 있습니다. 앱 또는 사용자가 데이터에서 수행하는 작업을 결정합시다. 데이터가 설정, 수정 또는 삭제됩니까? ... 그런 다음 해당 이벤트를 추적하기위한 조치가 필요합니다!

action을 <u>밑줄</u>로 표시하고 data를 **굵게** 표시하겠습니다.



#### Tweets List Component

![](https://video.udacity-data.com/topher/2018/March/5abd5744_nd019-redux-l7-store-01-tweet-list/nd019-redux-l7-store-01-tweet-list.png)

Tweets List Component의 경우, 우리가 볼 수 있는 유일한 정보는 모든 트윗 목록을 가져와야 한다는 것입니다. 따라서이 component의 경우 다음을 수행해야합니다.

- <u>get</u> the **tweets**

따라서 이벤트의 작업 유형은 아마도 `GET_LIST_OF_TWEETS` 또는 `GET_DATA`와 같습니다.



#### Tweet Component

![](https://video.udacity-data.com/topher/2018/March/5abd5771_nd019-redux-l7-store-02-tweet/nd019-redux-l7-store-02-tweet.png)

- 트윗 목록에서 특정 **tweets**을 <u>받습니다.</u> 
- **authedUser (현재 로그인 한 사용자)**를 <u>얻으므로</u> 각 **tweet**에서 좋아요를 <u>toggle</u>할 수 있습니다.
- 우리는 **authedUser**를 <u>얻으므로</u> 사용자는 tweet에 <u>답할 수 있습니다</u>.



#### Tweet Container Component

![](https://video.udacity-data.com/topher/2018/March/5abd578d_nd019-redux-l7-store-03-tweet-container/nd019-redux-l7-store-03-tweet-container.png)

- **tweets** 목록에서 특정 트윗을 <u>받습니다</u>.

- **tweets** 목록에서 특정 트윗에 대한 회신을 <u>받습니다</u>.



#### New Tweet Component

![](https://video.udacity-data.com/topher/2018/March/5abd57a6_nd019-redux-l7-store-04-new-tweet/nd019-redux-l7-store-04-new-tweet.png)

- 사용자가 새 **tweet**을 만들 수 있도록 **authedUser**를 <u>얻습니다</u>.
- **새 tweet의 텍스트**를 <u>설정</u>했습니다.



4단계로 넘어 가서, 위의 데이터 중 어떤 것이 상점에 존재할지 결정합니다.





### Step 4: Data and Store

#### Store에 어떤 데이터가 있는지 확인

Redux (및 react-redux 바인딩!)가 해결해야 할 주요 문제는 다음과 같습니다.

- 전체 component tree를 통한 props의 전파. 
- 앱에서 state의 일관성 및 예측 가능성 보장



Redux의 작성자인 Dan Abramov에 따르면, store 또는 React 컴포넌트에 데이터를 저장할지 여부를 결정하기 위해 다음 원칙을 따라야합니다.

> *"Use Redux for state that matters globally or is mutated in complex ways… The rule of thumb is: do whatever is less awkward."*
>
> **"전 세계적으로 중요하거나 복잡한 방식으로 변형된 상태에는 Redux를 사용하십시오. 경험상 규칙은 덜 어색한 것을 수행하는 것입니다."**

Take a look at [Organizing State](https://redux.js.org/faq/organizing-state) and [How to choose between Redux's store and React's state?](https://github.com/reactjs/redux/issues/1287) for further information about this.



3단계의 각 데이터 조각에 대해 여러 component에서 사용하는지 또는 복잡한 방식으로 변경했는지 확인하십시오.

> 새로운 트윗의 텍스트 사용 : New Tweet Component

이 데이터 조각은 여러 구성 요소에서 사용되지 않으며 복잡한 방식으로 변경되지 않습니다. 즉, store에 상주하는 앱 state 대신 component state에 대한 훌륭한 후보임을 의미합니다.

> 사용되는 트윗 :  Dashboard Component, Tweet Page Component, Tweet Component



Tweet Page Component에는 답글 트윗을 표시해야합니다. `_Data.js` 파일에서 시작 코드를 살펴 보겠습니다. 트윗이 데이터베이스에 저장되는 방식입니다.

```
let tweets = {
  tweetId: {
    id: tweetId,
    text: tweetText,
    author: userId,
    timestamp: timestamp,
    likes: [userId1, userId2],
    replies: [tweetId1, tweetId2],
    replyingTo: tweetId_OR_null
  }
};
```

답글 트윗을 받으려면 모든 트윗 목록에서 특정 ID를 가진 트윗을 가져와 해당 `replies` 속성에 액세스 할 수 있습니다.

Dashboard Component에서 현재 트윗 목록에 액세스해야합니다. Dashboard Component는 표시해야하는 트윗의 ID를 알고 있으면 해당 ID를 Tweet Component에 전달하면 해당 트윗을 렌더링 할 수 있습니다.

Tweet Component의 현재 트윗 목록에서 특정 ID를 가진 트윗을 선택해야합니다.

즉, 트윗을 store에 저장하고 Tweet Page Component, Dashboard Component 및 Tweet Component를 containers(`connect` 기능을 통해 store에 접근 할 수 있는 Component)로 만들 수 있습니다.

누군가가 트윗을 좋아하는 경우 해당 데이터가 변경되자마자 해당 데이터를 사용하는 모든 구성 요소가 업데이트됩니다.

![](https://video.udacity-data.com/topher/2018/March/5abd64fe_1-2/1-2.png)

각 트윗에는 author's name과  author's avatar가 포함되어 있습니다. 상태를 모델링 할 수 있는 한 가지 방법은 다음과 같습니다.

```
tweets: {
  tweetId: {tweetId, authorId, authorName, authorAvatar, timestamp, text, likes, replies, replyingTo},
  tweetId: {tweetId, authorId, authorName, authorAvatar, timestamp, text, likes, replies, replyingTo}
}
```

이러한 방식으로 상태를 모델링하는 것은 잘못된 것은 아니지만 나중에 특정 작성자가 작성한 트윗을 찾을 수 있도록 애플리케이션 기능을 확장하려는 경우 불편합니다.

또한 이러한 데이터 저장 방식은 두 가지 유형의 객체를 혼합합니다.

- tweets data
- user data

이것은 우리의 state를 정상화하라는 권고에 위배됩니다. [Redux 문서](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape)에 따르면 state 정규화 원칙은 다음과 같습니다.

- 각 유형의 데이터는 state에서 자체 "table"을 얻습니다.
- 각 "데이터 테이블"은 항목의 ID를 키로, 항목 자체를 값으로 사용하여 개별 항목을 객체에 저장해야합니다.
- 개별 품목에 대한 언급은 품목 ID를 저장하여 수행해야합니다.
- 순서를 나타내기 위해 ID 배열을 사용해야합니다.

우리의 응용 프로그램에서 정규화 된 상태는 다음과 같습니다.

```
{
  tweets: {
    tweet: { tweetId, authorId, timestamp, text, likes, replies, replyingTo},
    tweet: { tweetId, authorId, timestamp, text, likes, replies, replyingTo}
  },
  users: {
    user: {userId, userName, avatar, tweetsArray},
    user: {userId, userName, avatar, tweetsArray}
  }
}
```



이 시점에서 우리의 상점 :

![](https://video.udacity-data.com/topher/2018/March/5abd6595_1/1.png)

계속해서 데이터를 살펴 보겠습니다.

*authedUser* *Used by*: Tweet Component, New Tweet Component

각 Tweet Component는 로그인 한 사용자 특정 트윗을 좋아했는지 표시해야합니다. 그렇게하려면 로그인 한 사용자가 누구인지 알아야합니다. 2단계의 구성요소 계층을 살펴보면 Tweet 구성요소가 여러 구성요소에서 사용됨을 알 수 있습니다. 따라서 이 구성 요소를 컨테이너로 업그레이드하여 상점에서 인증된 사용자 데이터에 접근하여 하트를 표시할지 여부를 확인할 수 있습니다.

또한 모든 새 트윗에 대해 트윗 작성자 (authedUser)가 누구인지 기록해야합니다. 상태를 저장하는 React 방식은 상태를 가장 상위 구성 요소에 넣은 다음 이를 필요한 모든 하위 항목으로 전달하는 것입니다. 이 앱에서 이는 앱 컴포넌트에 저장하는 것을 의미합니다.

이를 수행하는 한 가지 방법은 authedUser를 앱 구성 요소에 저장한 다음 액세스 해야하는 구성요소로 전달하는 것입니다. 이는 작동하는동안 불편합니다. 인증된 사용자를 store에 저장한 후 상점에 대한 트윗 구성 요소 액세스를 제공하는 것이 훨씬 더 간단합니다. 새 트윗 구성 요소는 새 트윗의 텍스트와 새 트윗을 저장하기 위해 매개 변수로 회신하는 트윗의 ID로 조치를 전달할 수 있습니다.

트윗 저장은 비동기 작업이며 redux thunks를 사용하여 이를 수행할 수 있습니다. thunks는 우리에게 상점에 대한 액세스 권한을 부여하여 다음과 같은 action creator를 가질 수 있습니다.

```react
function handleAddTweet(text, replyingTo) {
  return (dispatch, getState) => {
    const { authedUser } = getState();

    return saveTweetToDatabase({
      text,
      author: authedUser,
      replyingTo
    }).then(tweet => dispatch(addTweet(tweet)));
  };
}
```

일반적으로 action creator로부터 store에 접근하는 것은 [반 패턴](https://stackoverflow.com/questions/35667249/accessing-redux-state-in-an-action-creator/35674575#35674575)으로 간주됩니다. 댄 아브라모프 (Dan Abramov)는 이를 수용할 수 있는 몇 가지 사용 사례는 다음과 같다고 말합니다.

> 요청하기 전에 캐시된 데이터를 확인하거나 인증 여부 (즉, 조건부 디스패치 수행)를 확인합니다.

authedUser 데이터를 스토어에 보관하려는 또 다른 이유는 로그인 및 로그아웃 기능을 포함하도록 애플리케이션을 확장하면 이 기능을 Redux로 쉽게 관리 할 수 있기 때문입니다.

새 트윗 구성요소는 인증된 사용자 상태에 액세스 할 필요는 없지만 리듀서에게 새 트윗이 작성되었음을 알리기 위해 조치를 전달할 수 있어야합니다. 디스패치 메소드에 액세스하려면 구성요소를 상점에 연결해야합니다. 즉, 컨테이너여야합니다. 따라서 트윗 구성 요소와 새 트윗 구성 요소가 모두 컨테이너로 업그레이드됩니다.



![](https://video.udacity-data.com/topher/2018/March/5abd5886_1/1.png)

우리는 store를 만들었습니다! store을 만드는 동안 container로 업그레이드 할 component도 결정했기 때문에 이제는 뼈대 앱이 더욱 완벽해졌습니다.

우리는 이제 코딩을 시작하기에 좋은 시점에 있습니다. 우리는 한눈에 살펴보고 골격의 세부사항을 그 길을 따라 채울 것입니다.





## Actions

Dashboard View에서 시작하겠습니다. Dashboard View에는 트윗 목록과 메뉴가 표시됩니다.

우리는 이 견해에서 일어나는 일을 살펴 볼 필요가 있습니다. 앱 또는 사용자가 데이터에 대해 수행중인 작업을 결정해 보겠습니다. 데이터가 설정, 수정 또는 삭제되고 있습니까?

계획 단계의 4단계에서 상점이 다음과 같이 보일 것임을 확인했습니다.

![](https://video.udacity-data.com/topher/2018/March/5abd65c5_1/1.png)

앱이 로드되면 Dashboard View가 표시됩니다. 따라서 Dashboard Component는 다음을 수행해야합니다.

- <u>get</u> the **tweets**
- <u>get</u> the **users**
- <u>get</u> the **authedUser**

이 데이터는 데이터베이스에 저장됩니다. 이 view가 모든 트윗(작성자의 아바타 포함)을 로드하려면 

1) 데이터베이스에서 트윗 및 사용자 데이터를 가져와야합니다. 

2) 해당 데이터를 구성 요소에 전달합니다.



> 다음 중 React 앱에서 API 요청에 대한 모범 사례는 무엇입니까? 해당되는 모든 것들을 고르세요.
>
> - The `componentDidMount()` lifecycle method



> 다음 중 React / Redux 앱에서 API 요청에 대한 모범 사례는 무엇입니까? 해당되는 모든 것들을 고르세요.
>
> - From asynchronous action creators
>
> 맞습니다! [redux-sagas](https://hackernoon.com/moving-api-requests-to-redux-saga-21780f49cbc8) 및 [axios 호출](https://github.com/svrcekmichal/redux-axios-middleware)과 같은 비동기 요청을 만드는 데 도움이되는 redux-thunk 외에 다른 부작용 관리 라이브러리가 있다는 것을 알고 있습니까? 이러한 라이브러리의 차이점에 대해 자세히 알아 보려면이 [기사](https://decembersoft.com/posts/what-is-the-right-way-to-do-asynchronous-operations-in-redux/)를 확인하십시오.



일반 액션 크리에이터가 액션을 반환하는 방법을 기억하십시오. 간단한 자바 스크립트 객체는 모든 리듀서로 이동합니다. API 요청은 비동기 작업이므로 일반 Javascript 객체를 리듀서로 보낼 수는 없습니다. Redux 미들웨어는 리듀서로 이동하는 중에 action에 액세스 할 수 있습니다. 이 예에서는 `redux-thunk` 미들웨어를 사용합니다.

Redux Thunk 미들웨어가 활성화 된 경우 (`applyMiddleware()` 함수를 통해 수행됨), 액션 크리에이터가 Javascript 오브젝트 대신 함수를 리턴 할 때마다 `redux-thunk` 미들웨어로 이동합니다.

Dan Abramov는 다음에 일어나는 일을 설명합니다.

> *“The middleware will call that function with dispatch method itself as the first argument...The action will only reach the reducers once the API request is completed. It will also “swallow” such actions so don't worry about your reducers receiving weird function arguments. Your reducers will only receive plain object actions—either emitted directly, or emitted by the functions as we just described.”*
>
> ''미들웨어는 디스패치 메소드 자체를 첫 번째 인수로 사용하여 해당 함수를 호출합니다 ... API 요청이 완료된 후에만 action이 reducer에 도달합니다. 또한 이러한 action을 "삼키기"때문에 reducer가 이상한 함수 인수를 받는 것에 대해 걱정하지 마십시오. reducer는 직접 방출되거나 방금 설명한대로 action에 의해 방출되는 일반 object action 만받습니다. "

thunk action creator의 모습은 다음과 같습니다.

```react
function handleInitialData () { 
 return function (dispatch) {}
}
```

ES6에서 이것과 동일합니다 :

```react
function handleInitialData () {
 return (dispatch) => {}
}
```

이제 컴포넌트에 들어온 데이터에 액세스 할 수 있도록해야합니다. 즉, store에 `tweets`과 `users`를 채워야합니다.



![](https://video.udacity-data.com/topher/2018/March/5abd66ac_image5/image5.png)

store에서 state의 **tweets** 슬라이스는 tweets reducer를 통과하는 action에 의해 수정됩니다. store의 **users** 상태 슬라이스는 users reducer를 통과하는 action에 의해 수정됩니다. 마찬가지로, store에서 state의 **authedUser** 부분은 authedUser Reducer를 통해 수행되는 action에 의해 수정됩니다.



가장 먼저해야 할 일은 `getInitialData`를 호출하는 것이다. 응용 프로그램에 필요한 초기 데이터를 다시 가져오는 방식이다.

먼저 새 `actions` 폴더를 만들고, 내부에 `authedUser.js`, `shared.js`, `tweets.js`, `users.js`를 만들자. tweet에 관련된 모든 작업이 될 것이다.



- shared.js

`util/api`에서 export되는 `getInitialData`함수를 가져오자.

이 function은 우리가 Redux를 return하는 pattern을 우리가 원하기 때문에 함수 내에서 비동기 요청을 한다.

이것은 사용자 속성이 있는 객체를 전달할 뿐 아니라, 우리에게 promise를 돌려줄 것이다.

그리고 지금 우리가 하고싶은 것은 우리는 users와 tweets을 가져와서 Redux store의 state에 추가하는 것이다. 

그러기 위해서는 몇가지 action이 필요하다.

```react
import { getInitialData } from '../utils/api'

export function handleInitialData () {
    return (dispatch) => {
        return getInitialData()
        	.then(({users, tweets}) => {
            
        })
    }
}
```

- tweets.js

먼저 이곳으로 와서 여기서 `RECEIVE_TWEETS`라고 부르는 새 변수를 내보낼 것이다. 이것은 store를 업데이트하기 위해 모든 tweet을 받고 발송할 때의 action type이 될 것이다.

그런 다음 내보내려는 함수를 receveTweets라고 한다. `RECEIVE_TWEETS` 유형의 객체 또는 action을 반환한다. 첫번째 인수로는 tweets를 전달한다.

이제 receiveTweets action creator가 있다.

```react
export const RECEIVE_TWEETS = 'RECEIVE_TWEETS'

export function receiveTweets (tweets) {
    return {
        type: RECEIVE_TWEETS,
        tweets,
    }
}
```

- users.js

이어서 user를 위해 비슷한 작업을 하겠다.

user를 받을 때 발생할 action type은 `RECEIVE_USERS`라고 할 것이다.

그리고 receiveUser action creator를 RECEIVE_USER type으로 내보내고 싶다. 그리고 users도 함께 전달한다.

```react
export const RECEIVE_USERS = 'RECEIVE_USERS' 

export function receiveUsers (users) {
    return {
        type: RECEIVE_USERS,
        users,
    }
}
```

- shared.js

이제 이곳에서 할 수 있는 작업은 서로 다른 action creator를 모두 가져올 수 있다.

아직 dispatch를 처리하지 않도록 reducer를 설정하지 않았더라도 이제 우리는 우리의 function 안에서 dispatch를 호출할 수 있다.

```react
import { getInitialData } from '../utils/api'
import { receiveTweets } from '../actions/tweets'
import { receiverUsers } from '../actions/users'

export function handleInitialData () {
    return (dispatch) => {
        return getInitialData()
        	.then(({users, tweets}) => {
            dispatch(receiveUsers(users))
            dispatch(receiveTweets(tweets))
        })
    }
}
```



이제 users 뿐만 아니라 tweets도 받고 있다. 우리 App의 최종 버전에서 인증된 users를 dispatch하는 방식을 보면, state에 authedUser 속성을 가지고 있다. 실제 인증을 구현하지는 않지만, 다시 인증하는 방법으로 인증된 사용자를 고수하려하고 있다. Redux store의 state는 tweets처럼 또는 새로운 tweets을 만들 때 마다 인증된 user가 누구인지 알게된다. 인증된 user는 이 3가지 옵션 중 하나일 수 있다.

우리의 데이터를 보면(`_DATA.js`) 원하는 사람을 선택할 수 있다.

우리가 할 일은 다시 shared.js에서 AUTHED_ID 상수를 생성한다.

이제 우리가 하고 싶은 것은 dispatch이다. AUTHED_ID를 Redux store의 속성으로 설정한다.

지금은 reducer를 설정하지는 않지만, 모든 작업을 완료하는 것이 좋다.

```react
import { getInitialData } from '../utils/api'
import { receiveTweets } from '../actions/tweets'
import { receiverUsers } from '../actions/users'

const AUTHED_ID = 'tylermcginnis'

export function handleInitialData () {
    return (dispatch) => {
        return getInitialData()
        	.then(({users, tweets}) => {
            dispatch(receiveUsers(users))
            dispatch(receiveTweets(tweets))
        })
    }
}
```



- authedUser.js

여기에 인증 된 user action type을 만들어보자. 그런 다음 인증 된  user action creator를 내보낸다. 이것은 id를 취할 것이다. 

```react
export const SET_AUTHED_USER = 'SET_AUTHED_USER'

export function setAuthedUser (id) {
    return {
        type: SET_AUTHED_USER,
        id
    }
}
```



- shared.js

ID와 함께 shared.js 내부에 전달하자. 우리가 하고 싶은 것은 actions/authedUser로부터 action creator를 가져오는 것이다.

그런 다음 user를 받고, tweet을 받으면 dispatch하고 싶은 것은 setAuthedUser가 인증된 id를 전달하도록 설정하는 것이다.

(우선 인증에 대한 걱정을 피하기 위해 하드 코딩했다. )

```react
import { getInitialData } from '../utils/api'
import { receiveTweets } from '../actions/tweets'
import { receiverUsers } from '../actions/users'
import { setAuthedUser } from '../actions/authedUser'

const AUTHED_ID = 'tylermcginnis'

export function handleInitialData () {
    return (dispatch) => {
        return getInitialData()
        	.then(({users, tweets}) => {
            dispatch(receiveUsers(users))
            dispatch(receiveTweets(tweets))
            dispatch(setAuthedUser(AUTHED_ID))
        })
    }
}
```

이제 모든 action creator 설정이 완료되었으며 이를 전달하고 있다. 다음으로 해야할 일은 실제로 reducer를 설정하는 것이다.

[수정된 코드 참고](https://github.com/udacity/reactnd-chirper-app/commit/acc11b20446b9e19dc861ab9ec46d9de57aa6ea8)





## Reducers & Middleware

#### Reducers

[Reducer](https://redux.js.org/basics/reducers)는 응용 프로그램의 상태가 어떻게 변하는지 설명합니다. reducer는 이전 상태를 변경하지 않고 새 객체를 반환해야하므로 reducer 내부에 [Object Spread Operator](https://redux.js.org/recipes/using-object-spread-operator)(...)가 사용되는 경우가 종종 있습니다. 스프레드 연산자에 대해 학습이 필요한 경우이 [ES6 레슨](https://classroom.udacity.com/nanodegrees/nd019/parts/290ec447-6555-41bf-ac39-457220a09aae/modules/9c5b7af0-0943-4d6e-b672-520440885aba/lessons/42383e89-ac6a-491a-b7d0-198851287bbe/concepts/398d36e6-3393-4c50-b870-44a4dffb0ac4)을 확인하십시오.

Redux에 불변성이 필요한 이유를 알고 싶다면 다음 문서의 [불변 데이터 섹션](https://redux.js.org/faq/immutable-data#why-is-immutability-required)을 확인하십시오.

Reducer에는 다음과 같은 signature가 있습니다.

```
(previousState, action) => newState
```

우리의 App에서 `tweets` reducer는 state의 `tweets` 부분이 어떻게 변경되는지 결정합니다. `users` reducer는 state의 `users` 부분이 어떻게 변하는지 등을 결정합니다.



![](https://video.udacity-data.com/topher/2018/March/5abd6717_image5/image5.png)



### Initializing State

store 내부에서 state를 초기화하는 두 가지 방법이 있습니다.

- 초기 상태(또는 초기 상태의 일부)를 `preloadedState`로 `createStore` 함수에 전달할 수 있습니다.

```react
const store = createStore (
  rootReducer,
  { tweets: {} }
);
```

- 특정 reducer 함수 내에서 첫 번째 인수로 기본 상태 매개 변수를 포함 할 수 있습니다.

```react
function tweets (state = {}, action) {
}
```

이러한 접근 방식이 어떻게 상호 작용하는지 보려면 [설명서의 초기화 상태 섹션](https://redux.js.org/recipes/structuring-reducers/initializing-state)을 확인하십시오.



이제 몇가지 action을 취하겠습니다. 실제로 reducer를 설정해야합니다. 

`src/reducers` 폴더를 만들고, `users.js`, `tweets.js`, `authedUser.js`, `index.js`를 생성합니다.

index.js에서는 reducer를 결합하기 위한 호출을 내보냅니다.

- users.js

```react
import { RECEIVE_USERS } from '../actions/users'

export default function users (state = {}, action) {
    switch(action.type) {
        case RECEIVE_USERS :
            return {
                ...state,
                ...action.users
            }
        default : 
            return state
    }
}
```

- tweets.js

```react
import { RECEIVE_TWEETS } from '../actions/tweets'

export default function tweets (state = {}, action) {
    switch(action.type) {
        case RECEIVE_TWEETS :
            return {
                ...state,
                ...action.tweets
            }
        default : 
            return state
    }
}
```

- authedUser.js

```react
import { SET_AUTHED_USER } from '../actions/authedUser'

export default function authedUser (state = null, action) {
    switch(action.type) {
        case SET_AUTHED_USER :
            return action.id
        default :
            return state
    }
}
```

이렇게 3가지의 reducer를 만들었다.



- index.js

combineReducers를 통해 reducer를 combind해서 내보내는 작업을 한다.

```react
import { combineReducers } from 'redux'
import authedUser from './authedUser'
import users from './users'
import tweets from './tweets'

export default combineReducers({
    authedUser,
    users,
    tweets
})
```



앱에서 기본 state 값을 각 reducer 함수의 첫 번째 매개 변수로 설정하여 store의 각 슬라이스를 초기화했습니다.

이 시점에서 우리 상점은 다음과 같습니다.

![](https://video.udacity-data.com/topher/2018/March/5abd6ca3_image4/image4.png)

Store에서 state의 Tweets 슬라이스와 Users 슬라이스가 빈 오브젝트로 초기화되었습니다. 그리고 store에있는 state의 authedUser 슬라이스가 null로 초기화되었습니다.

따라서 state의 Tweets 슬라이스를 관리하기위한 tweet, state의 Users 슬라이스를 관리하기위한 users reducer 및 state의 인증 된 사용자 부분을 관리하기위한 authedUser reducer가 있습니다. 이 reducer 각각은 state 자체를 관리합니다.

<u>이 reducer를 모두 하나의 기본 root reducer로 결합하여 tweets reducer, users reducer 및 authedUser reducer를 호출한 결과를 단일 상태 객체로 결합합니다. **createStore 함수는 단일 reducer 만 허용하므로 이를 수행해야합니다.**</u>

```react
combineReducers({
  authedUser: authedUser,
  tweets: tweets,
  users: users
});
```

또는 ES6의 속성 [속기](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)를 사용하면 다음과 같습니다.

```react
combineReducers({
  authedUser,
  tweets,
  users
});
```

이제 모든 reducer가 설정되었으므로 실제로 store을 작성하여 애플리케이션에 제공해야합니다. 지금까지 작성한 코드를 실제로 사용하려면 redux 패키지를 설치해야합니다. 그런 다음 애플리케이션에 store를 제공하려면 react-redux 패키지도 설치해야합니다.

```bash
$ yarn add react-redux redux
$ yarn upgrade react react-dom
```



따라서 reducers 폴더에서 기본 내보내기를 가져오면, 그것이 우리의 주요 root reducer가 될 것이다.이제 계속 진행해보겠다. 



- 우리는 store를 만들기를 원한다.

- Provider component에 App을 wrapping하길 원한다.
- 우리는 reducer를 원한다.
- 다음으로 store를 만들기 위해 reducer를 전달하는 create store를 호출한다.
- 이제 기본 App component를 이 Provider component 안에 넣을 수 있다.

```react
import React from 'react'
import ReactDOM from 'react-dom'
import './index.css'
import App from './components/App'
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import reducer from './reducers'

const store = createStore(reducer)

ReactDOM.render(
    <Provider store={store}>
    	<App />
    </Provider>, document.getElementById('root'))
```

이제 다음에 할 일은 action creator의 객체가 아닌 함수를 반환하는 경우 미들웨어에 추가하는 것이다.



Redux 애플리케이션에는 single store가 있습니다. store가 어떤 state 조각을 가져야하는지 root reducer를 `createStore()` 함수에 전달해야합니다. store 작성의 요점은 여러 component를 통해 데이터를 전달하지 않고도 component가 store에 액세스 할 수 있도록 하는 것입니다.

Provider component(react-redux 패키지에서 제공)는 모든 component가 `connect()` 함수를 통해 store에 액세스 할 수 있게합니다.



### Middleware

마지막 설정은 앱의 미들웨어 function 설정과 관련이 있습니다. 이전 Todos 애플리케이션과 마찬가지로 logger middleware를 작성하여 애플리케이션과 상호 작용할 때 store의 action 및 state를 볼 수 있습니다. 또한 `src/actions/shared.js`의 `handleInitialData()` action creator가 함수를 반환하므로 `react-thunk` 패키지를 설치해야합니다.

```bash
$ yarn add redux-thunk
```

다음에는 `redux-thunk` 미들웨어를 연결하여 thunk action creator가 실제로 작동하도록 하겠습니다. 또한 디버깅을보다 쉽게하기 위해 logger 미들웨어도 포함시킬 것입니다. 사용자 정의 미들웨어를 작성하는 방법을 기억하십니까?

모든 미들웨어는이 currying pattern을 따릅니다.

```react
const logger = (store) => (next) => (action) => {
 // ...
}
```

변수 `logger`는 `store`을 인수로 사용하는 함수에 지정됩니다. 이 함수는 `next`에 전달되는 다른 함수를 반환합니다 (next middleware in line 또는 dispatch function). 다른 function은 `action`이 전달 된 다른 함수를 반환합니다. 세 번째 `action`에 들어가면 `store`, `next` 및 `action`에 액세스 할 수 있습니다.

`next` 매개 변수의 값은 `applyMiddleware` 함수에 의해 결정됩니다. 왜? 모든 미들웨어는 해당 기능에 나열된 순서대로 호출됩니다. 우리의 경우 `logger`가 해당 function에 나열된 마지막 미들웨어이므로 `next`은 `dispatch`됩니다.



actions/shared.js에 보면 action creator에서 function을 반환하는 구문을 여기서 사용하고 있다. 이를 지원하기 위해 redux-thunk middleware를 연결해야한다.



`src/middleware` 폴더를 만들고, `index.js`, `logger.js`



- logger.js

새로운 state가 dispatch 된 후의 state뿐만 아니라 새로운 action이 발생될 때마다 알려준다.

```react
const logger = (store) => (next) => (action) => {
  	console.group(action.type)
    	console.log('The action: ', action)
    	const returnValue = next(action)
        console.log('The new state: ', store.getState())
    console.groupEnd()
    return returnValue
}

export default logger
```



- index.js

thunk middleware와 applyMiddleware, logger를 가져온다.

```react
import thunk from 'redux-thunk'
import logger from './logger'
import { applyMiddleware } from 'redux' 

export default applyMiddleware(
	thunk,
    logger,
)
```



- src/index.js

`src/index.js`로 돌아가서 store에서 middleware를 인식하고 있는지 확인해야 한다.

아래에 `import middleware from './middleware'` 코드를 적어줌으로써 `middleware/index.js`에서 export한 applyMiddleware가 호출이 될 것이다.

우리는 미들웨어를 전달할 수 있다.

우리가 할 일을 dispatch하지 않기 때문에 아직 아무것도 

```react
import React from 'react'
import ReactDOM from 'react-dom'
import './index.css'
import App from './components/App'
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import reducer from './reducers'
import middleware from './middleware'

const store = createStore(reducer, middleware)

ReactDOM.render(
    <Provider store={store}>
    	<App />
    </Provider>, document.getElementById('root'))
```



이제 다음에는 업로드할 것이다. 애플리케이션에 필요한 초기 데이터를 가져올 것이다.



미들웨어 wiring은 다음과 같습니다.

```js
export default applyMiddleware(
  thunk,
  logger
);
```

action creator가 반환한 모든 것(action 또는 function)은 thunk 미들웨어를 거치게됩니다. 다음은 thunk 미들웨어의 소스 코드입니다.

```react
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
```

thunk 미들웨어가 action을 발견하면 해당 action은 logger middleware in line의 next middleware로 전송됩니다. 함수가 보이면 thunk 미들웨어가 해당 함수를 호출합니다. 이 함수는 API 호출과 같은 부수적인 효과를 포함 할 수 있고 간단한 자바 스크립트 객체와 같은 action을 전달할 수 있습니다. 이러한 dispatch 된 action는 다시 모든 미들웨어로 이동합니다. thunk 미들웨어는 간단한 action임을 인식하고 다음 미들웨어 인 logger에 action를 전달합니다.



logger 내부에 들어가면 :

```js
const logger = store => next => action => {
  console.group(action.type); 
  console.log("The action:", action);
  const returnValue = next(action);
  console.log("The new state:", store.getState());
  console.groupEnd();
  return returnValue;
};
```



> Would these two pieces of code make the logger produce the same output in the console?
>
> ```js
> export default applyMiddleware(
>   logger,
>   thunk
> );
> ```
>
> ```js
> export default applyMiddleware(
>   thunk,
>   logger
> );
> ```
>
> - No
>
> 맞습니다! 미들웨어는 이 function에 나열된 순서대로 호출됩니다. 초기 날짜를 로드하고 트윗을 저장하고 트윗을 토글하는 데 사용하는 thunk action creator는 function입니다. 따라서 thunk middleware로 이동하기 전에 logger middleware로 이동하면 (function을 수행하고이를 수행하여 reducer에 전달할 action를 얻음) 실제 action이 아닌 function를 로깅하게됩니다.





## Initializing the App's Data

우리는 이전에 홈페이지가 load 될 때 데이터베이스에서 `users` 및 `tweets` 데이터를 가져와서 해당 데이터를 `authedUser` 데이터와 함께 store으로 보내야한다고 결정했습니다.

또한 데이터베이스에서 데이터를 가져와서 store에 action을 발송하여 store에 있는 세 가지 state를 설정하는 thunk action creator를 작성했습니다.

- `users`
- `tweets`
- `authedUser`

`handleInitialData()` thunk action creator는 다음과 같습니다.

```js
function handleInitialData () {
  return (dispatch) => {
    return getInitialData()
      .then(({ users, tweets }) => {
        dispatch(receiveUsers(users));
        dispatch(receiveTweets(tweets));
        dispatch(setAuthedUser(AUTHED_ID));
      });
  };
}
```

이제 이 action creator를 어디에 dispatch 해야 할까요?



> Think about this for a moment - Will our app work as desired if we dispatch the `handleInitialData()` action creator inside of the *Dashboard* Component?
>
> - No
>
> 맞습니다!  root route가 올바르게 로드되는 것은 사실이지만, 예를 들어 `tweets/:id`와 같은 다른 router로 이동하면 store가 여전히 비어 있고 트윗을 찾을 수 없습니다.



App architecture를 살펴보면 App component에 다른 모든 component가 포함되어 있음을 알았습니다. App component에서 `handleInitialData()` action creator를 전달하여 초기 데이터를 로드하면 사용자가 어느 경로로 이동하든 올바른 데이터가 모두 표시됩니다.



이제 초기 데이터를 처리하기 위해 action creator를 설정했으므로, 우리는 dispatch될 필요가 있는 우리의 다양한 action들을 모두 만들었다. reducer를 설치했고, 그 dispatch를 처리한다.

다음으로 해야할 일은 실제로 App이 load 될 때, `handleInitialData`되도록 하는 것이다.



- components/App.js

우리가 할 일은 components 폴더 내 App.js에서 우리가 원하는 것은 몇가지 다른 것을 가져오는 것이다.

connect와 `handleInitialData` function import한다.

이제 이 component가 mount 될 때, handleInitailData action creator의 호출을 발송하려고 한다. 하지만 dispatch를 받으려면, 우리가 할 일은 App component를 connect해야하므로 connect하기만 하면 된다. (주의 : 우리는 state에서 필요한 것이 없으므로 첫번째 호출은 비워둔다.)

이제 componentDidMount 내부에서 우리가 할 수 있는 것은 this.props.dispatch(handleInitialData()) action creator를 호출할 수 있다.

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { handleInitialData } from '../actions/shared'

class App extends Component {
    componentDidMount() {
        this.props.dispatch(handleInitialData())
    }
    render() {
        return (
        	<div>
            	Starter Code
            </div>
        )
    }
}

export default connect()(App)
```

이제 새로고침해보면, 초기 상태의 데이터를 가져오는 것은 console창에서 확인할 수 있다.



`connect()` 함수를 사용하면 component를 container로 업그레이드합니다. container는 store에서 state를 읽고 action를 dispatch할 수 있습니다. react-redux API 문서에서 container와 store의 관계를 사용자 정의하는 기능에 대해 자세히 알아보십시오. 





## Dashboard Component

계획 단계의 4단계에서 store은 다음과 같아야합니다.

우리의 응용 프로그램에서 정규화 된 state는 다음과 같습니다.

```js
{
  tweets: {
    tweetId: { tweet id, author’s id, timestamp, text, likes, replies, replyingTo},
    tweetId: { tweet id, author’s id, timestamp, text, likes, replies, replyingTo}
  },
  users: {
    userId: {user’s id, user’s name, avatar, tweets array},
    userId: {user’s id, user’s name, avatar, tweets array}
  }
}
```

계획 단계에서는 또한 트윗 목록을 표시하기 위해 대시 보드 구성 요소가 store의 트윗 부분에 액세스해야하므로 container가 될 것이라고 결정했습니다.

컨테이너를 만들려면 `connect()` 함수를 사용해야합니다. 연결 함수의 서명은 다음과 같습니다.

```js
connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])
```

`mapStateToProps` 및 `mapDispatchToProps`에 대한 이러한 세부 사항은 중요합니다.

> `mapStateToProps` - 이 인수가 지정되면 새 컴포넌트는 Redux store 업데이트를 구독합니다. 즉, store가 업데이트 될 때마다 `mapStateToProps`가 호출됩니다. `mapStateToProps`의 결과는 일반 객체여야하며 component의 prop으로 병합됩니다. 저장소 업데이트를 구독하지 않으려면 `mapStateToProps` 대신 null 또는 undefined를 전달하십시오.

> `mapDispatchToProps` - 객체가 전달되면 그 안의 각 함수는 Redux action creator로 간주됩니다. 함수 이름은 같지만 모든 action creator가 dispatch 호출로 래핑되어 직접 호출 될 수 있는 객체는 component의 props에 병합됩니다. 함수가 전달되면 첫 번째 매개 변수로 dispatch가 제공됩니다. action creator를 자신의 방식으로 바인딩하기 위해 dispatch를 사용하는 객체를 반환하는 것은 사용자의 몫입니다. (팁 : Redux의 `bindActionCreators()` 도우미를 사용할 수 있습니다.)

계획 단계의 2단계에서 만든 component 계층 구조를 기억하십니까? 우리는 트윗 component가 대시 보드 component 안에 있을 것이라고 말했습니다. 대시 보드 component는 표시해야하는 트윗의 ID를 알고 있으면 해당 ID를 트윗 component에 전달하면 해당 트윗을 렌더링 할 수 있습니다.

mapStateToProps 함수의 서명은 다음과 같습니다.

```js
mapStateToProps(state, [ownProps])
```

- state는 상점 내부의 상태입니다.
- ownProps는 상위 컴포넌트에서 이 component로 전달된 특성입니다.

우리는 store의 트윗 부분에만 관심이 있기 때문에, 구조화를 사용하여 store의 state의 트윗 부분을 `mapStateToProps()` 함수에 매개 변수로 전달할 수 있습니다.



![](https://video.udacity-data.com/topher/2018/March/5abd6d18_untitled-diagram-21/untitled-diagram-21.png)

대시 보드 component의 `mapStateToProps()` 함수는 다음과 같습니다.

```js
function mapStateToProps( {tweets} ){
  return { tweetIds: Object.keys(tweets) };
}
```

유의해야 할 사항은 다음과 같습니다.

- 트윗은 이 component가 관심을 갖는 state의 조각입니다.
- tweetIds가 이 컨테이너의 속성으로 표시됩니다



이제 응용 프로그램에 대한 초기 데이터가 확보되었으므로 다음으로 할 것은 바로 대시보드 component를 만드는 것이다. 



`components` 폴더안에 Dashboard.js라는 파일을 만들어보겠다.

```react
import React, { Component } from 'react' 

class Dashboard extends Component {
    render() {
        return (
        <div>
        	Dashboard    
       	</div>
        )
    }
}

export default Dashboard
```

이제 대시보드 구성을 갖추었으니 우리가 대답해야 할 다음 질문은 어떤 데이터이다. 이 대시보드 구성요소는 Redux store state에서 필요합니까?



이 대시보드의 책임은 다른 모든 트윗을 렌더링하는 것이다. 기능을 만들어보자.

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'

class Dashboard extends Component {
    render() {
        console.log(this.props)
        return (
        <div>
        	Dashboard    
       	</div>
        )
    }
}

function mapStateToProps ({ tweets }) {
    return {
        tweetsIds: Object.keys(tweets)
        	.sort((a,b) => tweets[b].timestamp - tweets[a].timestamp)
    }
}

export default connect(mapStateProps)(Dashboard)
```



- components/App.js

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { handleInitialData } from '../actions/shared'
import Dashboard from './Dashboard'

class App extends Component {
    componentDidMount() {
        this.props.dispatch(handleInitialData())
    }
    render() {
        return (
        	<div>
            	<Dashboard/>
            </div>
        )
    }
}

export default connect()(App)
```



이제 대시보드에서 모든 실제 트윗을 렌더링하는 대신 UI 렌더링을 시작하자.

- Dashboard.js

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'

class Dashboard extends Component {
    render() {
        return (
        <div>
        	<h3 className='center'>Your TimeLine</h3>    
            <ul className='dashboard-list'>
                {this.props.tweetsIds.map((id) =>(
                	<li key={id}>
                    	<div>TWEET ID: {id}</div>
                    </li>
                ))}
            </ul>
       	</div>
        )
    }
}

function mapStateToProps ({ tweets }) {
    return {
        tweetsIds: Object.keys(tweets)
        	.sort((a,b) => tweets[b].timestamp - tweets[a].timestamp)
    }
}

export default connect(mapStateToProps)(Dashboard)
```

트윗 ID를 전달하는 트윗 구성요소를 빌드하는 작업은 이후로 미루고 다시 App으로 돌아가자.



- App.js

초기 데이터의 데이터가 한번만 대시보드로 렌더링되도록하고 싶다. 우리는 store에서 data를 가져와야 한다. 우리가 원하는 것은 인증된 사용자이다. 로딩하는 동안에는 null을 렌더링한다.

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { handleInitialData } from '../actions/shared'
import Dashboard from './Dashboard'

class App extends Component {
    componentDidMount() {
        this.props.dispatch(handleInitialData())
    }
    render() {
        return (
        	<div>
                {this.props.loading === true
                 ? null 
                 : <Dashboard/>
                }
            </div>
        )
    }
}

function mapStateToProps ({authedUser}) {
    return {
        loading: authedUser === null
    }
}

export default connect(mapStateToProps)(App)
```

다음에는 개별 트윗에 대한 UI를 구축해보자. 그렇게 하면 모든 ID를 매핑하고 ID만 표시하는 대신 우리는 모든 ID를 매핑하고 실제 트윗을 보여줄 것이다.





## Tweet Component

Plan 단계의 4단계에서 Component가 다음 데이터에 접근해야한다는 것을 알았습니다.

- `users`
- `tweets`
- `authedUser`

이 Component를 Store에 연결하십시오!



이제 렌더할 트윗의 다양한 ID 목록이 모두 생겼으니, 다음으로 해야할 일은 우리가 Tweet Component를 구축할 수 있도록 ID를 전달하면 각 개별 트윗을 렌더해야한다.



- components/Tweet.js

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { formatTweet } from '../utils/helpers'

class Tweet extends Component {
    render() {
    	console.log(this.props)
        return (
            <div className='tweet'>
            </div>
        )
    }
}

function mapStateToProps ({authedUser, users, tweets},{id}){
    const tweet = tweets[id]
    
    return {
        authedUser,
        tweet: formatTweet(tweet, users[tweet.author], authedUser)
    }
}

export default connect(mapStateToProps)(Tweet)
```



- Dashboard.js

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import Tweet from  './Tweet'

class Dashboard extends Component {
    render() {
        return (
        <div>
        	<h3 className='center'>Your TimeLine</h3>    
            <ul className='dashboard-list'>
                {this.props.tweetsIds.map((id) =>(
                	<li key={id}>
                    	<Tweet id={id}>
                    </li>
                ))}
            </ul>
       	</div>
        );
    }
}

function mapStateToProps ({ tweets }) {
    return {
        tweetsIds: Object.keys(tweets)
        	.sort((a,b) => tweets[b].timestamp - tweets[a].timestamp)
    };
}

export default connect(mapStateToProps)(Dashboard);
```



Tweet components에 ID props을 전달하는 방법에 주목하십시오.

```react
<Tweet id={id} />
```

이 작업을 수행하므로 `mapStateToProps` 함수의 두 번째 인수 (`ownProps`)는이 값을 가진 `id` 속성을 가진 객체가됩니다.

![](https://video.udacity-data.com/topher/2018/March/5abd6d97_untitled-diagram-21-4/untitled-diagram-21-4.png)

현재 `mapStateToProps` 함수는 다음과 같습니다.

```react
function mapStateToProps ({authedUser, users, tweets}, {id}){
    const tweet = tweets[id];
    
    return {
        authedUser,
        tweet: formatTweet(tweet, users[tweet.author], authedUser)
    }
}
```

여기서 주목해야 할 것은 `mapStateToProps`가 두 개의 인수를 허용한다는 것입니다.

- the state of the store ( store의 상태 )
- the props passed to the Tweet component ( props이 트윗 component에 전달됨 )

우리는 두 가지 주장을 모두 파괴하고 있습니다. store에서 다음을 추출합니다.

- the `authedUser` data
- the users data
- the tweets data

그런 다음 트윗 component에 전달 된 props에서 `ID`를 가져옵니다. Tweet component에 의해 표시되어야하는 Tweet을 판별할 수 있도록 store의 state와 component에서 오는이 두 가지 데이터가 필요합니다.



이제 View를 렌더링하는데 필요한 거의 모든 데이터가 있습니다. 그러나 우리가 놓친 것은 부모 트윗, 트윗이 다른 트윗에 대한 회신이 있는지 여부를 알 수 없다.

그래서 우리는  부모 트윗과 우리가 트윗 component에 전달하는 객체와 함께 다음 정보를 전달해야한다.

- Tweet.js

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { formatTweet } from '../utils/helpers'

class Tweet extends Component {
    render() {
		const { tweet } = this.props

        if (tweet === null){
            return <p>This Tweet doesn't existed</p>
        }

	    console.log(this.props)

        return (
        <div ClassName='tweet'>
        </div>
        )
    }
}

function mapStateToProps ({authedUser, users, tweets},{id}){
    const tweet = tweets[id]
    const parentTweet = tweet ? tweets[tweet.replyingTo] : null
    
    return {
        authedUser,
        tweet: tweet ? formatTweet(tweet, users[tweet.author], authedUser, parentTweet) : null
    }
}

export default connect(mapStateToProps)(Tweet)
```

완성된 것으로 보면 특정 트윗의 속성중에 replyingTo가 있다면, 그것은 다른 트윗에 대한 응답임을 나타낸다.



Tweet Component의 `mapStateToProps` 함수의 최종 상태는 다음과 같습니다.

```react
function mapStateToProps ({authedUser, users, tweets}, {id}){
    const tweet = tweets[id];
    const parentTweet = tweet ? tweet[tweet.replyingTo] : null;
    
    return {
        authedUser,
        tweet: tweet,
         ? formatTweet(tweet, users[tweet.author], authedUser, parentTweet)
         : null
    };
}
```

store에서 필요한 모든 데이터를 얻었으므로 실제로 Tweet 구성 요소의 UI를 빌드 할 수 있습니다.



우리는 몇가지 다른 아이콘을 사용할 것이다. 따라서 `react-icons` 패키지를 설치해야한다.

```bash
$ yarn add react-icons
```



- components/Tweet.js

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { formatTweet, formatDate } from '../utils/helpers'
import { TiArrowBackOutline } from 'react-icons/ti/index'
import { TiHeartOutline } from 'react-icons/ti/index'
import { TiHeartFullOutline } from 'react-icons/ti/index'

class Tweet extends Component {
    handleLike = (e) => {
            e.preventDefault()
            // todo: Handle Like Tweet
    }
    toParent = (e, id) => {
        e.preventDefault()
        // todo: Redirect to parent Tweet.
    }
    
    render() {
        const { tweet } = this.props

        if (tweet === null){
            return <p>This Tweet doesn't existed</p>
        }

        const {
            name, avartar, timestamp, text, hasLiked, likes, replies, parent
        } = tweet

        return (
        <div ClassName='tweet'>
                <img 
                    src={avatar}
                    alt={`Avatar of ${name}`}
                    className='avartar'
                />
                <div className='tweet-info'>
					<div>
                    	<span>{name}</span>
                    	<div>{formatDate(timestamp)}</div>
                   	 	{parent && (
                            <button 
                                className='replying-to' 
                                onClick={(e) => this.toParent(e, parent.id)}
                            >
                        	Replying to @{parent.author}
	                        </button>
    	                )}
        	            <p>{text}</p>
	                </div>
                    <div className='tweet-icons'>
                        <TiArrowBackOutline className='tweet-icon'/>
                        <span>{replies !== 0 && replies}</span>
                        <button className='heart-button' onClick={this.handleLike}>
                            {hasLiked === true ? <TiHeartFullOutline color='#e0245e' className='tweet-icon'/> : <TiHeartOutline className='tweet-icon'/>}
                        </button>
                        <span>{likes !== 0 && likes}</span>
                    </div>
                </div>
        	</div>
        )
    }
}

function mapStateToProps ({authedUser, users, tweets},{id}){
    const tweet = tweets[id]
    const parentTweet = tweet ? tweets[tweet.replyingTo] : null
    
    return {
        authedUser,
        tweet: tweet ? formatTweet(tweet, users[tweet.author], authedUser, parentTweet) : null
    }
}

export default connect(mapStateToProps)(Tweet)
```

[수정 코드 참고](https://github.com/udacity/reactnd-chirper-app/commit/6db39add5b99c8e4996896ff3454c0239de4d5cc)



이제 타임 라인보기 또는 대시보드 보기를 위한 UI가 있습니다.

현재 앱을 새로고침하면 모든 데이터가 로드될 때까지 UI에 아무것도 표시되지 않습니다. Redux 전용 로딩 바를 다운로드 해서 로드될 때 표시해주도록 하자.



```bash
$ yarn add react-redux-loading
```



- reducers/index.js

reducer store에서 app의 현재 로드 상태에 대한 일부 정보를 전달하자.

```react
import { combineReducers } from 'redux'
import authedUser from './authedUser'
import users from './users'
import tweets from './tweets'
import { loadingBarReducer } from 'react-redux-loading'

export default combineReducers({
    authedUser,
    users,
    tweets,
    loadingBar: loadingBarReducer
})
```

loadingBar를 내부에서 사용하려면 응용 프로그램에는 몇 가지 action creator가 필요하다.

로딩 바 상태를 변경하기 위해 dispatch할 수 있으며, 렌더링 할 수 있는 컴포넌트가 필요하다. 로딩 바의 실제 Ui를 표시한다.



`react-redux-loading` 패키지는 다른 것(showLoading, hideLoading 등)들을 우리에게 제공한다.

이는 npm의 패키지이지만, 오픈 소스 라이브러리이다. 우리가 제공한 action creator를 계속 사용할 수 있다.



- actions/shared.js

```react
import { getInitialData } from '../utils/api'
import { receiveTweets } from '../actions/tweets'
import { receiverUsers } from '../actions/users'
import { setAuthedUser } from '../actions/authedUser'
import { showLoading, hideLoading } from 'react-redux-loading'

const AUTHED_ID = 'tylermcginnis'

export function handleInitialData () {
    return (dispatch) => {
        dispatch(showLoading())
        return getInitialData()
        	.then(({users, tweets}) => {
            dispatch(receiveUsers(users))
            dispatch(receiveTweets(tweets))
            dispatch(setAuthedUser(AUTHED_ID))
            dispatch(hideLoading())
        })
    }
}
```



- component/App.js

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { handleInitialData } from '../actions/shared'
import Dashboard from './Dashboard'
import LoadingBar from 'react-redux-loading'

class App extends Component {
    componentDidMount() {
        this.props.dispatch(handleInitialData())
    }
    render() {
        return (
        	<div>
                <LoadingBar />
                {this.props.loading === true
                 ? null 
                 : <Dashboard/>
                }
            </div>
        )
    }
}

function mapStateToProps ({authedUser}) {
    return {
        loading: authedUser === null
    }
}

export default connect(mapStateToProps)(App)
```

[수정 코드 참고](https://github.com/udacity/reactnd-chirper-app/commit/1fdbaaa20d45fbb94dc461405f756f17815f20fd)



#### Further Research

- [The Perils of Using a Common Redux Anti-Patterns](https://itnext.io/the-perils-of-using-a-common-redux-anti-pattern-344d778e59da)





## Liking a Tweet

Planning 단계에서는 로그인 한 사용자가 트윗을 좋아했는지 여부와 사용자가 트윗에 응답할 수 있도록 트윗 component에 트윗 된 component의 authedUser 데이터에 대한 액세스 권한을 부여해야한다는 것을 알았습니다. 또한 사용자가 트윗을 좋아하거나 싫어하면 다른 component가 올바른 데이터를 표시하기 위해 해당 정보를 store에 반영해야한다는 것도 알아냈습니다.

로그인 한 사용자가 store뿐만 아니라 데이터베이스에서도 트윗을 좋아했는지 여부를 기록해야하므로 비동기 action creator를 작성해야합니다. Redux는 구조에 [thunks](https://github.com/reduxjs/redux-thunk)!



![](https://video.udacity-data.com/topher/2018/March/5abd6f56_untitled-diagram-22/untitled-diagram-22.png)



thunk action creator로 쓸 수 있습니다.

```react
function handleToggleTweet (info) {
    return (dispatch) => {
        saveLikeToggle(info)
        .then(() => {
            dispatch(toggleTweet(info));
        })
        .catch((e) => {
            console.warn('Error in handleToggleTweet: ', e);
            alert('There was an error liking the tweet. Try again. ');
        });
    };
}
```



백엔드 업데이트에 성공했다는 확인을 받은 후에만 코드가 UI를 업데이트합니다. 이렇게하면 앱이 게으른것처럼 보일 수 있습니다.

UI 업데이트에 대한 일반적인 접근 방식은 Optimistic (낙관적) 업데이트입니다. 백엔드에 작업이 기록되기 전에 UI를 업데이트하므로 성능이 더 좋아보입니다. 트윗 액션을 구축 할 때 아래 비디오에서 이러한 접근 방식을 볼 수 있습니다.



지금은 타임라인에서 ♡를 클릭해도 아무런 기능도 설정하지 않았기 때문에 아무일도 일어나지 않는다.

기능을 만들어보자. 그러기 위해 `utils/api.js`을 보면 `saveLikeToggle`이라는 함수는 저장을 하기 위해 호출하는 함수임을 알 수 있다. 가짜 데이터베이스와 비슷하다.

그래서 우리는 `actions/tweets.js`로 가서 우리의 action을 위한 파일로 넘어가 그 함수를 가져오겠다.

- actions/tweets.js

```react
import { saveLikeToggle } from '../utils/api'

export const RECEIVE_TWEETS = 'RECEIVE_TWEETS'
export const TOGGLE_TWEET = 'TOGGLE_TWEET'

export function receiveTweets (tweets) {
  return {
    type: RECEIVE_TWEETS,
    tweets,
  }
}

function toggleTweet ({id, authedUser, hasLiked}){
    return {
        type: TOGGLE_TWEET,
        id,
        authedUser,
        hasLiked
    }
}

export function handleToggleTweet (info) {
    return (dispatch) => {
        dispatch(toggleTweet(info))
        
        return saveLikeToggle(info)
        	.catch((e)=> {
            console.warn('Error in handleToggleTweet: ', e)
            dispatch(toggleTweet(info))
            alert('The was an error liking the tweet. Try again.')
        })
    }
}
```



### Like Tweet Reducer

tweets reducer는 state의 tweets 부분이 어떻게 변하는지 결정합니다.

![](https://video.udacity-data.com/topher/2018/March/5abd6e49_untitled-diagram-23/untitled-diagram-23.png)



트윗을 좋아하거나 트윗이 마음에 들지 않을 때 특정 트윗의 상태를 변경해야합니다. (기억한다면 배열과 트윗을 좋아한 사용자의 이름을 포함합니다) 클릭 한 사용자를 포함하도록 (tweet를 좋아하는 경우) 포함하도록 변경해야합니다. 그렇지 않으면 사용자의 이름을 배열에서 제거해야합니다 (tweet를 원하지 않는 경우).

따라서 이러한 변경 사항을 처리하려면 reducer를 업데이트해야합니다.



- reducer/tweets.js

```react
import { RECEIVE_TWEETS, TOGGLE_TWEET } from '../actions/tweets'

export default function tweets (state={}, action) {
  switch (action.type) {
    case RECEIVE_TWEETS:
      return {
        ...state,
        ...action.tweets
      }
    case TOGGLE_TWEET:
      return {
        ...state,
		[action.id] :{
            ...state[action.id],
            likes: action.hasLiked === true
	            ? state[action.id].likes.filter((uid) => uid !== action.authedUser)
            	: state[action.id].likes.concat([action.authedUser])
        }
      }
    default :
      return state
  }
}
```





- components/Tweets.js

```react
{...}
import { handleToggleTweet } from '../actions/tweets'

class Tweet extends Component {
    handleLike = (e) => {
        e.preventDefault()
        
        const { dispatch, tweet, authedUser } = this.props
        
        dispatch(handleToggleTweet({
            id: tweet.id,
            hasLiked: tweet.hasLiked,
            authedUser,
        }))
    }
    toParent = (e, id) => {
        e.preventDefault()
        // todo: Redirect to parent Tweet.
    }
    
    render() {...}
}

{...}
```

[수정 코드 참고](https://github.com/udacity/reactnd-chirper-app/commit/936be890e97aa1f241e792ccd3c542964dd71aa5)





## New Tweet Component

새로운 트윗을 추가하는 기능을 만들어보자.



- components/NewTweet

```react
import React, { Component } from 'react'

class NewTweet extends Component{
    state = {
        text: '',
    }
	handleChange = (e) => {
        const text = e.target.value
        
        this.setState(() => ({
            text
        }))
    }
    handleSubmit = (e) => {
        e.preventDefault()
        
        const { text } = this.state
        
        // todos: Add Tweet to Store
        
        this.setState(() => ({
            text: ''
        }))
    }
    render() {
        const { text } = this.state
        
        {/* todo: Redirect to / if submitted */}
        
        const tweetLeft = 280 - text.length
        
        return (
        	<div>
                <h3 className='center'>Compose new Tweet</h3>
                <form className='new-tweet' onSubmit={this.handleSubmit}>
                	<textarea
                      placeholder="What's happening?"
                      value={text}
                      onChange={this.handleChange}
                      className='textarea'
                      maxlength={280}
                    />
                    {tweetLeft <= 100 && (
                    	<div className='tweet-length'>
                        	{tweetLeft}
                        </div>
                    )}
                    <button 
                        className='btn'
                        type='submit'
                        disabled={text === ''}>
                        submit
                    </button>
                </form>
            </div>
        )
    }
}

export default NewTweet
```



대시보드를 렌더링하는 대신 우리가 지금 만들 NewTweet을 렌더링하게 만들자.

- component/App.js

```react
{...}
import NewTweet from './NewTweet'
 
 class App extends Component {
     {...}
     render(){
         return (
             {...}
              // < Dashboard /> 대신, 
         	: <NewTweet /> }
             {...}
     }
 }
```



### Adding a New Tweet

이제 새 트윗을 추가하는 logic에 대해 알아 보겠습니다. 사용자가 새 트윗을 제출하면 모든 트윗 목록에 표시되고 데이터베이스에 추가되어야합니다. 이 트윗은 둘 이상의 component에 의해 사용될 것이므로, 업데이트 된 트윗 목록을 반영하도록 store을 수정하고 싶다는 것을 알고 있습니다. 데이터베이스에 트윗을 기록하는 것은 비동기 작업이므로 Redux Thunk를 사용하여 API 요청을 발행 할 수 있습니다.



이제 우리가 하고 싶은 것은 `submit` 버튼을 누를 때 마다 새로운 트윗을 콘솔에 기록하게 하고 싶다. 실제로 Redux store의 state를 새로운 tweet으로 업데이트하고자 한다.



- actions/tweets

```react
import { saveLikeToggle, saveTweet } from '../utils/api';
import { showLoading, hideLoading } from 'react-redux-loading'

export const RECEIVE_TWEETS = 'RECEIVE_TWEETS';
export const TOGGLE_TWEET = 'TOGGLE_TWEET';
export const ADD_TWEET = 'ADD_TWEET';

function addTweet (tweet) {
    return {
        type: ADD_TWEET,
        tweet,
    }
}

export function handleAddTweet (text, replyingTo) {
    return (dispatch, getState) => {
        const { authedUser } = getState()
        
        dispatch(showLoading())
        
        return saveTweet({
            text,
            author: authedUser,
            replyingTo
        })
        .then((tweet) => dispatch(addTweet(tweet)))
        .then(() => dispatch(hideLoading()))
    }
}

export function receiveTweets(tweets) {
  return {
    type: RECEIVE_TWEETS,
    tweets
  };
}

function toggleTweet({ id, authedUser, hasLiked }) {
  return {
    type: TOGGLE_TWEET,
    id,
    authedUser,
    hasLiked
  };
}

export function handleToggleTweet(info) {
  return dispatch => {
    dispatch(toggleTweet(info));

    return saveLikeToggle(info).catch(e => {
      console.warn('Error in handleToggleTweet: ', e);
      dispatch(toggleTweet(info));
      alert('The was an erro liking the tweet. Try again.');
    });
  };
}
```



이 시점에서 일반적인 JavaScript 버그를 신속하게 다루겠습니다.

화살표 함수에 중괄호가 있을 때마다 무언가를 반환하려면 return 문을 사용해야합니다.



> Given this array, `const nums = [1,2,3];` Which statements produce the following output `[3,3,3]` ? Select all that apply.
>
> - `nums.map(num => nums.length);`
> - `nums.map( {return num => nums.length});`



우리는 우리 store가 다음과 같다는 것을 알고 있습니다.

```
{
  tweets: {
    tweetId: { tweetId, authorId, timestamp, text, likes, replies, replyingTo}, 
    tweetId: { tweetId, authorId, timestamp, text, likes, replies, replyingTo}
  },
  users: {
    userId: {userId, userName, avatar, tweets array},
    userId: {userId, userName, avatar, tweets array}
  },
  authedUser: userId
}
```

New Tweet Reducer에 대한 작업을 시작하겠습니다. 새 트윗을 반영하도록 상태를 어떻게 수정합니까?

이것은 두 부분으로 구성된 프로세스가 될 것입니다.

1. 새 트윗을 트윗 목록에 추가해야합니다.
2. 새 트윗이 다른 트윗에 대한 응답인 경우 이미 존재하는 트윗을 수정해야합니다.

이 리듀서에서는 1) 새로운 트윗을 기존 트윗 목록에 연결합니다. [object spread operator](https://redux.js.org/recipes/using-object-spread-operator)는 우리에게 가장 간결한 방법을 제공합니다. 2) 새 트윗이 회신하는 트윗의 회신 속성을 수정합니다.



- reducers/tweets

```react
import { RECEIVE_TWEETS, TOGGLE_TWEET, ADD_TWEET } from '../actions/tweets';

export default function tweets(state = {}, action) {
  switch (action.type) {
    case RECEIVE_TWEETS:
      return {
        ...state,
        ...action.tweets
      };
    case TOGGLE_TWEET:
      return {
        ...state,
        [action.id]: {
          ...state[action.id],
          likes:
            action.hasLiked === true
              ? state[action.id].likes.filter(uid => uid !== action.authedUser)
              : state[action.id].likes.concat([action.authedUser])
        }
      };
      case ADD_TWEET:
        const { tweet } = action
        
        let replyingTo = {}
        
        if (tweet.replyingTo !== null) {
            replyingTo = {
                [tweet.replyingTo]: {
                    ...state[tweet.replyingTo],
                    replies: staet[tweet.replyingTo].replies.concat([tweet.id])
                }
            }
        }
        
        return {
        	...state,    
            [action.tweet.id]: action.tweet,
            ...replyingTo,
        }
    default:
      return state;
  }
}
```



- components/NewTweet

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { handleAddTweet } from '../actions/tweets'

class NewTweet extends Component{
    state = {
        text: '',
    }
	handleChange = (e) => {
        const text = e.target.value
        
        this.setState(() => ({
            text
        }))
    }
    handleSubmit = (e) => {
        e.preventDefault()
        
        const { text } = this.state
        const { dispatch, id } = this.props
        
        dispatch(handleAddTweet(text, id))
        
        
        this.setState(() => ({
            text: ''
        }))
    }
    render() {
        const { text } = this.state
        
        {/* todo: Redirect to / if submitted */}
        
        const tweetLeft = 280 - text.length
        
        return (
        	<div>
                <h3 className='center'>Compose new Tweet</h3>
                <form className='new-tweet' onSubmit={this.handleSubmit}>
                	<textarea
                      placeholder="What's happening?"
                      value={text}
                      onChange={this.handleChange}
                      className='textarea'
                      maxlength={280}
                    />
                    {tweetLeft <= 100 && (
                    	<div className='tweet-length'>
                        	{tweetLeft}
                        </div>
                    )}
                    <button 
                        className='btn'
                        type='submit'
                        disabled={text === ''}>
                        submit
                    </button>
                </form>
            </div>
        )
    }
}

export default connect()(NewTweet)
```

[수정 코드 참고](https://github.com/udacity/reactnd-chirper-app/commit/993f1b903e62bbd9ba78afdf4e8d698b7a0b8c66)

+. 새로운 Tweet을 작성해서 ADD_TWEET이 발송되는지 확인하기



Plannig 단계의 2단계에서 사용자가 `/new` 페이지로 이동하면 New  Tweet Component가 App Component 안에 표시되고 사용자가 `/tweet/:id`  페이지에 있으면 Tweet Page Component내에 표시됩니다.

사용자가 `/new` 경로에 있으면 New Tweet이 다른 트윗에 첨부되지 않습니다. 사용자가 `tweet/:id` 경로에 있을 때, 새로운 트윗은 이미 표시된 트윗에 첨부됩니다. 경로에는 이미 부모 트윗의 ID가 포함되어 있습니다. 답글을 작성할 때마다 경로에서 새 트윗 구성 요소로 ID를 전달하면됩니다.

 누군가가 “Submit”을 클릭하여 새 트윗을 추가하면 어떻게됩니까? New  Tweet Component는 Store와 통신해야합니다. 우리는 action를 dispatch하여 Store와 통신합니다. dispatch는 Store의 방법입니다. 이것은 New  Tweet Component가 Redux에 `connect()`되어야 한다는 것을 의미합니다. Component가 Store에 연결되면 props에 dispatch됩니다.



> When will the `mapStateToProps` function be called? Select all that apply.
>
> - Anytime the store is updated
> - Whenever the component receives new props



- components/TweetPage

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import Tweet from './Tweet'
import NewTweet from './NewTweet' 

class TweetPage extends Component{
    render(){
		const { id, replies } = this.props
        return(
        	<div>
                <Tweet id={id} />
                <NewTweet id={id} />
                {replies.length !== 0 && <h3 className='center'>Replies</h3>}
                <ul>
                	{replies.map((replyId) => (
                    	<li key={replyId}>
                        	<Tweet id={replyId} />
                        </li>
                    ))}
                </ul>
            </div>
        )
    }
}

function mapStateToProps ({ authedUser, tweets, users}, props){
    const { id } = props.match.params
    
    return {
        id,
        replies: !tweets[id] 
        	? [] 
        	: tweets[id].replies.sort((a, b) => tweets[b].timestamp - tweets[a].timestamp)
    }
}

export default connect(mapStateToProps)(TweetPage)
```



- components/App

```react
{...}
import TweetPage from './TweetPage'
 
 // <NewTweet />을 렌더링 하는 대신 <TweetPage />을 렌더링하도록 코드 수정
 			: <TweetPage match={{params: {id: '8xf0y6ziyjabvozdd253nd'}}}/>
{...}
```

[수정 코드 참고](https://github.com/udacity/reactnd-chirper-app/commit/171ed69e495cadab991aff900b9ad5e2f4005c20)



이제 애플리케이션의 모든 View를 모두 마쳤다.

다음으로 해야할 일은 실제로 React Router에 추가하여, URL을 기반으로 렌더링되는 Component를 동적으로 변경한다.



### Lesson Challenge

 `reducers/tweets` 파일의 코드 `case ADD_TWEET:` 을 아래 코드로 대체했다고 가정해 봅시다.

- 상태가 같은 방식으로 변경됩니까? 그 이유는 무엇?
- 새 트윗이 페이지에 나타 납니까? 그 이유는 무엇?

Run the code to check your answer.

```react
...
case ADD_TWEET :
   const { tweet } = action

   let replyingTo = {}
   if (tweet.replyingTo !== null) {
      const allReplies = state[tweet.replyingTo].replies.concat([tweet.id]);

      return {
      ...state,
      [action.tweet.id]: action.tweet,
      [action.tweet.replyingTo.replies]: allReplies
      }
   }

   return {
      ...state,
      [action.tweet.id]: action.tweet,
      ...replyingTo,
   }
...
```

#### Further Learning

Carefully go over the [Immutable Update Patterns](https://redux.js.org/recipes/structuringreducers/immutableupdatepatterns) and [Designing the State Shape](https://redux.js.org/basics/reducers#designing-the-state-shape) pages in the Redux documentation.

Remember, that [doing a shallow copy of the top level is not sufficient - [nestedState objects\] should be copied as well.](https://redux.js.org/recipes/structuringreducers/immutableupdatepatterns)





## Using React Router

우리는 앱의 모든 것을 거의 끝냈습니다!

마지막 단계는 앱이 라우팅을 처리하도록하는 것입니다. 우리는 React Router를 할 수 있습니다.



### Quick [React Router](https://reacttraining.com/react-router/web/guides/philosophy) Review

#### `BrowserRouter` Component

`BrowserRouter`는 URL의 변경사항을 수신하고 URL이 변경될 때 올바른 화면이 표시되는지 확인합니다.

```js
<BrowserRouter>
   <App />
</BrowserRouter>
```

우리가 할 수 있도록

- use the other components `browser-router-dom` comes with inside of our app (브라우저 내부의 다른 구성 요소를 사용하면 앱 내부에 제공됩니다.)
- listen to the URL so that whenever the url changes, the routing components will be notified of the change (URL이 변경될 때마다 라우팅 구성 요소에 변경사항이 통지되도록 URL을 청취하십시오.)



#### `Link` Component

```js
<Link to="/about">About</Link>
```

사용자는 `Link` Component의 도움으로 React 앱을 탐색합니다.

Link 구성 요소는 BrowserRouter와 통신하여 URL을 업데이트하도록 지시합니다. to 속성을 Link 구성 요소에 전달하면 라우팅 할 경로를 앱에 알려줍니다.

상태를 새로운 경로로 전달하려면 어떻게해야합니까? props to Links에 문자열을 전달하는 대신 다음과 같은 객체를 전달할 수 있습니다.

```js
<Link to={{
 pathname: '/courses',
 search: '?sort=name',
 hash: '#the-hash',
 state: { fromDashboard: true }
}}>
 Courses
</Link>
```



URL을 기반으로 렌더링되는 구성요소를 동적으로 변경할 수 있도록 React Router를 추가해보자.

```bash
$ yarn add react-router-dom
```



- components/Nav

```react
import React from 'react'
import { NavLink } from 'react-router-dom'

export default function Nav () {
    return (
    	<nav className='nav'>
            <ul>
            	<li>
                	<NavLink to='/' exact activeClassName='active'>
                    Home
                    </NavLink>
                </li>
                <li>
			      	<NavLink to='/new' exact activeClassName='active'>
                    New Tweet
                    </NavLink>
                </li>
            </ul>
        </nav>
    )
}
```



- components/App

```react
import React, { Component, Fragment } from ;'react'
import { BrowserRouter as Router, Route } from 'react-router-dom'
{...}
import Nav from './Nav'
 
class App extends Component {
    {...}
    render(){
        return (
            <Router>
                <Fragment>
					<LoadingBar />
            		<div className='container'>
                        <Nav />
                        {this.props.loading === true
                            ? null
                            : <div>
                                <Route path='/' exact component={Dashboard} />
                                <Route path='/tweet/:id' exact component={TweetPage} />
                                <Route path='/new' exact component={NewTweet} />
                              </div>}
                    </div>
                </Fragment>
            </Router>
```



- components/NewTweet

```react
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { handleAddTweet } from '../actions/tweets'
import { Redirect } from 'react-router-dom'

class NewTweet extends Component{
    state = {
        text = '',
        toHome: false,
    }
	handleChange = (e) => {
        const text = e.target.value
        
        this.setStaet(() => ({
            text
        }))
    }
    handleSubmit = (e) => {
        e.preventDefault()
        
        const { text } = this.state
        const { dispatch, id } = this.props
        
        dispatch(handleAddTweet(text, id))
        
        
        this.setState(() => ({
            text: '',
            toHome: id ? false : true,
        }))
    }
    render() {
        const { text, toHome } = this.state
        
		if (toHome === true) {
            return <Redirect to='/' />
        }
        
        const tweetLeft = 280 - text.length
        
        return (
        	<div>
                <h3 className='center'>Compose new Tweet</h3>
                <form className='new-tweet' onSubmit={this.handleSubmit}>
                	<textarea
                      placeholder="What's happening?"
                      value={text}
                      onChange={this.handleChange}
                      className='textarea'
                      maxlength={280}
                    />
                    {tweetLeft <= 100 && (
                    	<div className='tweet-length'>
                        	{tweetLeft}
                        </div>
                    )}
                    <button 
                        className='btn'
                        type='submit'
                        disabled={text === ''}>
                        submit
                    </button>
                </form>
            </div>
        )
    }
}

export default connect()(NewTweet)
```



이제 특정 트윗 선택하면 그 트윗 화면으로 이동하도록 설정



- components/Tweet

```react
import { Link } from 'react-router-dom'

{...}

const { name, avatar, timestamp, text, hasLiked, likes, replies, id, parent } = tweet

return (
	// <div className='tweet'>
    <Link to={`/tweet/${id}`} className='tweet'>
        {...}
    </Link>
)
```



이제 특정 트윗 내 답장 버튼을 클릭하면, 그들이 답장을 보낸 트윗으로 이동하도록 해보자.



- components/Tweet

```react
import { Link, withRouter } from 'react-router-dom'

{...}

toParent = (e, id) => {
    e.preventDefault()
    this.props.history.push('/tweet/${id}')
}

{...}

export default withRouter(connect(mapStateToProps)(Tweet))
```

[수정 코드 참고](https://github.com/udacity/reactnd-chirper-app/commit/512ddca69dd99d67acf4b9795b1000c2e728e899)





## Lesson Summary

프로젝트가 완료되었다. UI를 제어하기 위한 React와 Redux를 사용하여 state를 관리하는 Twitter 복제본을 완성했다. 이보다 복잡한 Redux 애플리케이션에 대해 어떻게 생각하나요?



#### Lesson Challenge

연구에 따르면 우리가 배우고 자하는 것에 대한 예에 노출되면 그러한 개념과 아이디어에 대해 더 깊이 이해하는 데 도움이됩니다. 따라서 [these React/Redux sample projects](https://github.com/reactjs/redux/tree/master/examples)를 통해 재료에 대한 이해를 튼튼하게하고 React / Redux 앱 구축을위한 다양한 아키텍처를 배우는 것이 좋습니다. 시도하는 방법은 다음과 같습니다.

1. 각 예를 살펴보고 어떻게
   - 구성 요소가 함께 작동합니다. 
   - 상점에 저장된 정보; 
   - 상점의 데이터가 어떻게 수정되는지; 
   - 프로젝트 구성 방식
2. 다른 예제의 아키텍처 간의 유사점과 차이점을 결정하십시오.
3. 시간이 있다면 몇 가지 예를 다운로드하여 새로운 기술을 연습하도록 변경하십시오.

이렇게하면 React / Redux 프로젝트를 처리하기위한 체계적인 프레임 워크를 개발하는 데 도움이됩니다.



#### Further Research

- [Compilation of React & Redux Links by Mark Erikson](https://github.com/markerikson/react-redux-links)





## Course Summary

지금까지 프로그램에서 성취 한 내용이 지금까지의 경력에 어떻게 부합되는지 보여줍니다.

![](https://video.udacity-data.com/topher/2018/July/5b60f781_screen-shot-2018-07-31-at-4.57.34-pm/screen-shot-2018-07-31-at-4.57.34-pm.png)