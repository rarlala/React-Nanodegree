# React Router



## React Router Intro

브라우저 내부에서 JavaScript를 사용하여 UI를 렌더링하면 때때로 사람들은 이것을 Single-Page Apps(단일 페이지 응용 프로그램)이라 부른다.

![image-20200128112909279](C:\Users\정수지\AppData\Roaming\Typora\typora-user-images\image-20200128112909279.png)

실제로 웹사이트는 사용자가 웹사이트를 방문하면 브라우저는 웹사이트 서버에서 페이지를 요청하고 서버는 HTML을 생성하여 전송한다. 사용자가 탐색하면 브라우저는 서버에서 새 페이지를 요청한다. 서버는 새 페이지의 HTML을 브라우저로 보낸다. 사용자에게 새 페이지가 나타난다. 사용자가 탐색할 때마다 주기가 반복된다.

사람들이 Single-Page Apps를 말할 때 앱에 화면이 하나만 있는 것은 아니다. 이는 새 페이지를 위해 브라우저가 서버로 돌아갈 필요가 없음을 의미한다. 대신 JavaScript는 페이지 간 전환을 처리할 수 있다. 따라서 서버에서 보낸 초기 페이지는 하나 뿐이다. 이것이 Single-Page Apps(단일 페이지 응용 프로그램)이라고 하는 이유다.

React Router는 React를 사용하여 단일 페이지 응용 프로그램을 구축할 수 있는 도구이다. Contacts App에 router를 추가하는데 사용하겠다.



### Single-Page Apps

Single-Page Apps은 다른 방식으로 작동할 수 있다. Single-Page Apps이 로드되는 한가지 방법은 전체 사이트 내용을 한번에 다운로드하는 것이다. 이렇게하면 사이트를 탐색할 때 모든 것이 이미 브라우저에서 사용 가능하므로 페이지를 새로 고칠 필요가 없다. Single-Page Apps이 작동하는 방식은 사용자가 요청한 페이지를 렌더링하는 데 필요한 모든 것을 다운로드하는 것이다. 그런 다음 사용자가 새 페이지를 탐색하면 요청된 컨텐츠에 대해서만 비동기 JavaScript 요청이 작성됩니다.

Single-Page Apps의 좋은 또 다른 요소는 URL이 페이지 내용을 제어한다는 것이다. Single-Page Apps은 대화식 기능이 뛰어나고 사용자는 URL만 사용하여 특정 상태로 돌아갈 수 있기를 원한다. 이것이 왜 중요한가? 북마크 기능! (단, 단어가 아닌지 확인...) 사이트를 책갈피로 지정할 때 해당 책갈피는 URL일 뿐이며 해당 페이지의 상태를 기록하지 않는다.

앱에서 수행한 작업이 페이지의 URL을 업데이트하지 않는 것을 봤는가? 북마크 가능한 페이지를 제공하는 React 애플리케이션을 만들어야한다.



### React Router

React Router는 React 프로젝트를 Single-Page Apps으로 전환한다. 링크 생성을 관리하고, 앱의 URL을 관리하고, 다른 URL 위치를 탐색할 때 전환을 제공하는 등 다양한 특수 구성 요소를 제공하여 이를 수행한다.

React Router 웹 사이트에 따르면

> React Router is a collection of **navigational components** that compose declaratively with your application. (React Router는 애플리케이션을 선언적으로 구성하는 navigational components 모음입니다)

다음 섹션에서는 프로젝트 this.state 객체의 값에 따라 페이지에 내용을 동적으로 렌더링 할 것이다. 상태를 통해 보이는 것을 제어하여 React Router가 작동하는 방식에 대한 아이디어로 기본 예제를 사용합니다. 그런 다음 React Router 사용으로 전환합니다. 링크와 URL을 관리 할 수 있도록 React Router를 설치하고 프로젝트에 추가하고 모든 것을 연결하는 과정을 안내합니다.



>추가 자료 
>
>https://reacttraining.com/





## Dynamically Render Pages

새 연락처를 만들어 서버에 저장할 수있는 양식을 만들어 보자.

form이 항상 표시되는 것을 원하지 않으므로 설정이 활성화 된 경우에만 form이 표시되도록 하자. 이 설정을 `this.state`에 저장하자. 이 방법을 사용하면 React Router의 기능에 대한 아이디어를 얻을 수 있다.



- CreateContact.js 파일 생성

```react
import React, { Component } from 'react'

class CreateContact extends Component {
  render(){
    return(
      <div>Create Contact</div>
    )
  }
}

export default CreateContact
```



- App.js에 import 후 state에 따라 screen을 다르게 출력

```react
import React, { Component } from 'react'
import ListContacts from './ListContacts'
import * as ContactsAPI from './utils/ContactsAPI'
import CreateContact from './CreateContact'

class App extends Component {
  state = {
    contacts :[],
    screen: 'list'
  }
  componentDidMount(){
    ContactsAPI.getAll()
      .then((contacts)=>{
        this.setState(()=> ({
          contacts
        }))
      })
  }
  removeContact = (contact) => {
    this.setState((currentState) => ({
        contacts: currentState.contacts.filter((c) => {
        return c.id !== contact.id
        })
    }))
    ContactsAPI.remove(contact)
  }
  render(){
    return (
      <div>
        {this.state.screen === 'list' && (<ListContacts
         contacts={this.state.contacts}
         onDeleteContact={this.removeContact}
        />
        )}
        {this.state.screen === 'create' && (
          <CreateContact />
        )}
      </div>
    )
  }
}

export default App
```



우리는 새 연락처를 작성하기 위해 양식을 담당할 CreateContact component를 작성했다. 선호하는 컴포지션의 일반적인 React 테마를 유지하면서 이를 독립형 컴포넌트로 작성하고 `App` 컴포넌트의 `render()` 메소드에 추가하여 컴포지션을 사용했다.

React Router의 작동 방식을 매우 간단하게 재현하기 위해 this.state에 화면 속성을 추가하고 이 속성을 사용하여 화면에 표시할 내용을 제어했다. `this.state.screen`이 목록이면 모든 기존 연락처 목록이 표시된다. `this.state.screen`이 생성되면 CreateContact 컴포넌트가 표시된다.



### Short-circuit Evaluation Syntax(단락 평가 구문)

보여줄 section을 만들 때 생소한 구문을 사용했다.

```react
{this.state.screen === 'list' && (
  <ListContacts
  contacts={this.state.contacts}
  onDeleteContact={this.removeContact}
  />
)};
```

와 

```react
{this.state.screen === 'create' && (
  <CreateContact />
)}
```

이것은 컴포넌트의 JSX 코드와 표현식을 실행하는 코드와 혼동될 수 있다. 그러나 이것은 논리식 &&이다.

```
expression && expression
```

여기서 사용하는 것은 단락 평가라고하는 JavaScript 기술이다. 첫번째 식이 참으로 평가되면 두번째 식이 실행된다. 그러나 첫번째 식이 거짓으로 평가되면 두번째 식을 건너뛰게 된다. 정확한 구성 요소를 표시하기 전에 먼저 `this.state.screen`의 값을 확인하는 가드로서 이것을 사용하고 있다.

> For a deeper dive into this, check out [the short-circuit evaluation info on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation).



### Add A Button

앱이 다른 화면을 표시하도록 하려면 상태를 수동으로 변경해야한다. 우리는 사용자가 앱 자체에서 이를 제어 할 수 있기를 원하므로 버튼을 추가하자!



- 검색바 옆에 연락처 추가 버튼 추가

```react
// ListContacts.js

<a
    href='#create'
    onClick={()=>({})}
    className='add-contact'>Add Contact
</a>
```



- onNavigate 메서드 추가 및 동작 구현

```react
// App.js

<ListContacts
    contacts={this.state.contacts}
    onDeleteContact={this.removeContact}
    onNavigate={() => {
    	this.setState(()=>({
    	screen: 'create'
    }))
  	}}
/>
```



- click에 위에서 만들어 넘겨준 메소드 동작하도록 작성

```react
// ListContacts.js

const { contacts, onDeleteContact, onNavigate } = this.props
  ...
  <a
      href='#create'
      onClick={onNavigate}
      className='add-contact'>Add Contact</a> 
```



UI와 URL을 동기화 된 상태로 유지할 수 있다. 링크 화면과 URL에 대한 모든 사용자의 기대를 그대로 유지한다. 이것이 React Router가 존재하는 이유이다.



### Dynamic Routing Recap

이 섹션에서 추가 한 코드에서 state를 사용하여 사용자에게 표시 할 내용을 제어하려고 했다. 그러나 뒤로 버튼을 사용할 때 문제가 발생하는 것을 보았다.

이제 앱의 화면을 관리하기 위해 React Router 사용으로 전환하겠다.