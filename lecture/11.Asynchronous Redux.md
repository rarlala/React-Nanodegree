# Asynchrounons Redux

이제 우리의 앱은 데이터를 추가하고 지울 수 있고, 그 데이터는 Redux 내부에 있다. 하지만 우리의 모든 데이터는 앱 자체 내에 로컬로 존재하는데 이는 현실적이지 않다.



실제로는 해당 데이터가 데이터베이스를 사용하면 API를 통해 데이터베이스와 상호 작용할 수 있다. 우리는 이렇게 만들기 위해 모든 데이터를 외부 API로 옮기고 데이터가 비동기화되면 Redux가 어떻게 바뀌는지 볼 것이다.



이 레슨에서는 (시뮬레이션 된) 원격 데이터베이스로 작업 할 것입니다. 제공된 API를 사용하여 이 데이터베이스와 상호 작용합니다.

이 레슨에서 배우게 될 중요한 기술은 **Redux에서 비동기 요청을 하는 방법**입니다. Redux가 지금 작동하는 방식은 다음과 같습니다.

- `store.dispatch()` 호출이 이루어집니다.
- Redux 저장소가 미들웨어로 설정된 경우 해당 기능이 실행됩니다.
- 감속기가 호출됩니다

그러나 데이터를 가져오기 위해 외부 API와 상호 작용해야하는 경우 어떻게 처리해야합니까? 예를 들어, Todos 앱에 데이터베이스에서 기존 Todos를 로드하는 버튼이있는 경우 어떻게 해야합니까? 해당 조치를 전달하면 현재 원격 Todo 항목 목록이 리턴 될 때까지 기다리는 방법이 없습니다.

이 과정을 마친 후에는 비동기 요청을하고 Redux 애플리케이션에서 원격 데이터로 작업 할 수 있습니다.



## External Data

데이터베이스를 사용하여 Todos 애플리케이션과 상호작용할 것입니다. 프로젝트의 측면을 덜 복잡하게 유지하기 위해 데이터베이스를 시뮬레이션하고 있습니다. 다음 비디오에서 사용할 데이터베이스를 애플리케이션에 추가하는 데 필요한 HTML 스크립트 태그입니다.

```html
<script src="https://tylermcginnis.com/goals-todos-api/index.js"></script>
```



현재 앱 내 모든 데이터는 클라이언트 전용입니다. 일반적으로는 서버와 상호 작용한 다음 해당 서버가 데이터베이스와 상호 작용합니다. 새 할 일 항목이나 목표를 저장할 때마다 이 사실을 서버에 알려줘야합니다. 그런 다음 데이터베이스에 알려줘야 합니다. 하지만 지금은 서버가 없기 때문에 우리가 하는 모든 일은 단지 클라이언트 측입니다. Application을 새로고치면 그 모든 것들이 사라집니다.

우리가 할 일은 index.js 파일을 참조하는 새 스크립트를 여기에 포함시킬 것 입니다.

```html
<script src="https://tylermcginnis.com/goals-todos-api/index.js"></script>
```

이 파일은 실제로 볼 수 있습니다. 이 파일에서는 API라는 창 객체에 속성을 추가합니다. 그런 다음 이 데이터와 상호 작용하고 싶을 때마다 그것은 다시 가짜 데이터베이스에 살고 있다. 예를 들어 목표를 가져오려면 `API.fetchGoals`를 호출합니다. 

이제 우리는 Redux는 데이터가 비동기적으로 들어올 때 어떻게 작동할지 알아봐야한다.



> Take a look at the [API](https://tylermcginnis.com/goals-todos-api/index.js). Which method will get all Goals?
>
> ```
> API.fetchGoals = function () { return new Promise((res, rej) => { setTimeout(function () { res(goals) }, 2000) }) }
> ```



> API에서 자체를 중지하기 전에 saveTodo 메소드가 얼마나 오래 실행됩니까?
>
> 0.3초



### 🔨Task

프로젝트에 다음 동작을 추가하십시오.

- 앱이 로드되면, `console.log`는 모든 할 일과 가짜 데이터베이스에 있는 모든 목표를 기록합니다.

**[Solution Code]**

```react
class App extends React.Component {
    componentDidMount () {
        const { store } = this.props

        Promise.all([
            API.fetchTodos(),
            API.fetchGoals()
        ]).then(([ todos, goals ]) => {
            console.log('Todos', todos)
            console.log('Goals', goals)
        })
        ...
}
```



### Promise-Based API

제공된 API의 메소드는 모두 Promise기반입니다. `.fetchTodos()` 메소드를 살펴 봅시다.

```javascript
API.fetchTodos = function () {
  return new Promise((res, rej) => {
    setTimeout(function () {
      res(todos);
    }, 2000);
  });
};
```

새로운 `Promise()` 객체를 생성하고 반환하는 방법을 확인하십시오.

위의 작업에서 모든 할 일과 모든 목표를 가져올 수 있었지만 일련의 작업이므로 사용자가 불필요하게 오랜 시간을 기다리게 만드는 것입니다. API는 Promise 기반이므로 `Promise.all()`을 사용하여 모든 Promises가 해결 될 때까지 기다렸다가 콘텐츠를 사용자에게 표시 할 수 있습니다.

Promise는 비동기식이며 이 레슨은 모두 비동기 데이터 및 비동기 요청에 대한 작업에 관한 것입니다. Promise에 대해 조금 확신이 없다면 [MDN에 대한 Promise 문서](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)를 확인하거나 [JavaScript Promises 코스](https://www.udacity.com/course/javascript-promises--ud898)를 확인하십시오.



이제 우리가 해야할 일은 실제로 이 데이터를 Redux Store에 알려야한다.

우리의 모든 목표와 모든 행동에 대해 우리는 많은 행동을 파견할 것이다. 새로운 action creator를 만들면 어떨까?

```react
const RECEIVE_DATA = 'RECEIVE_DATA';

function receiveDataAction(todos, goals){
    return{
        type: RECEIVE_DATA,
        todos,
        goals,
    }
}
```



이제 특정 행동을 기반으로 store의 state를 바꾸고 싶다. (goal도 유사하게 추가)

```react
function todos(state = [], action) {
    switch (action.type) {
        case ADD_TODO:
            return state.concat([action.todo]);
        case REMOVE_TODO:
            return state.filter(todo => todo.id !== action.id);
        case TOGGLE_TODO:
            return state.map(todo =>
                             todo.id !== action.id
                             ? todo
                             : Object.assign({}, todo, { complete: !todo.complete })
                            );
        case RECEIVE_DATA:
            return action.todos
        default:
            return state;
    }
}
```

여기서 일어나는 일은 `RECEIVE_DATA`가 발송될 때, state를 업데이트 할 뿐만 아니라 store의 여러 부분에 영향을 준다.



이제 우리가 해야할 일은 App 컴포넌트 내부로 돌아가는 것이다.

```react
class App extends React.Component {
    componentDidMount () {
        const { store } = this.props

        Promise.all([
            API.fetchTodos(),
            API.fetchGoals()
        ]).then(([ todos, goals ]) => {
            store.dispatch(receiveDataAction(todos, goals))
        })
        ...
}
```

위 코드까지 작성한 후 새로고침을 하면 초기 Todo List를 모두 얻는다.

[전체 코드 참고](https://github.com/udacity/reactnd-redux-todos-goals/commit/98d9b5468262eb4ea786cb55c3d68ed9de78af09)



근데 새로고침 후 2초 뒤에 데이터를 가져오기 때문에 유저를 속이는 것 같이 보인다. 데이터가 로드될 때까지 데이터가 없는 것 같아 보이기 때문이다. 그래서 로딩되고 있다는 것을 알려주기위해 작은 로딩 표시기를 보여주고 싶다.



>**로딩 표시기 구현**
>
>이 시점에서 앱을 새로 고칠 때 UI만 로드되는 것 같습니다. 데이터 (예 : 할 일 및 목표)가 실제로 화면에 나타나기 전에 눈에 띄는 지연이 있습니다. 사용자에게 원활한 환경을 제공하기 위해 콘텐츠를 가져올 때 화면에 로딩 표시기가 있으면 좋을 것입니다.
>
>이 기능을 어떻게 구현하시겠습니까? 이 상태에서 추적해야합니까? 새로운 구성 요소를 만들어야합니까? 감속기의 경우 새로운 논리가 필요합니까? 아래에 의견을 적어주세요.

`render()`는 순수한 함수여야하며 `componentDidMount()`  이전에 실행됩니다.



앱의 로딩 상태를 담당할 새로운 리듀서를 만들어보자.

```react
function loading (state = true, action){
    switch(action.type) {
        case RECEIVE_DATA:
            return false
        default:
            return state
    }
}
```



이제 이 새로운 reducer를 store에 추가하기 위해 우리가 해야할 일은 reducer를 결합하는 속성으로 아래와 같이 전달하는 것이다.

```react
const store = Redux.createStore(
    Redux.combineReducers({
        todos,
        goals,
        loading,
    }),
    Redux.applyMiddleware(checker, logger)
);
```

```react
class App extends React.Component {
    ...
    render() {
        ...
        const { todos, goals, loading } = store.getState();
        if (loading === true ){
            return (<h1>loading </h1>)
        }
        ...
    }
}
```



### Summary

이 섹션에서는 외부 API로 작업하는 방법을 살펴보았습니다. 우리는 새로운 액션 (`RECEIVE_DATA`)을 추가하고, 새로운 액션 크리에이터를 만들고, 새로운 리듀서를 만들었습니다. 모두 원격 데이터를 가져 오는 동안 앱이 가질 수있는 다양한 상태를 처리합니다.

- 앱에 데이터가 있기 전에

- 앱이 데이터를 가져오는 동안
- 데이터가 수신 된 후 다음 

섹션에서는 수행되는 API 작업을 기반으로 UI를 낙관적으로 업데이트하는 방법을 살펴 보겠습니다.



## Optimistic Updates

비동기 요청을 처리 할 때는 항상 약간의 지연이 수반됩니다. 고려하지 않으면 이상한 UI 문제가 발생할 수 있습니다. 예를 들어, 사용자가 할 일 항목을 삭제하려고 할 때 사용자가 "삭제"를 클릭 할 때부터 해당 항목이 데이터베이스에서 제거 될 때까지의 전체 프로세스에 2 초가 걸립니다. 서버에서 확인을 기다려 클라이언트의 목록에서 항목을 제거하도록 UI를 설계 한 경우 사용자는 "삭제"를 클릭 한 다음 UI에서 해당 업데이트를 보려면 2 초 동안 기다려야합니다. 최고의 경험은 아닙니다.

대신에 **optimistic updates**라는 기술이 있습니다. 서버에서 확인을 기다리는 대신 사용자가 "삭제"를 클릭하면 UI에서 사용자를 즉시 제거한 다음 서버가 사용자가 실제로 삭제되지 않았다는 오류로 다시 응답하면 정보를 다시 추가 할 수 있습니다. 이 방법으로 사용자는 UI에서 즉각적인 피드백을 받을 수 있지만 요청이 여전히 비동기적입니다.



**optimistic updates**를 살펴보자.

이제 우리는 실제로 항목을 삭제해보자. 이때 우리는 Redux store만 업데이트 하는 것이 아니라, DB도 업데이트 하고 싶다.



만약 todo에서 `removeItem`메소드가 호출될 때, store를 업데이트 하는 대신 API를 업데이트 해야한다. 이에 접근하는 한가지 방법은 API.deleteTodo를 호출하여 할 일의 id를 전달하는 것이다. 그리고 그것이 해결될 때 dispatch 호출해준다.

```react
removeItem = todo => {
    return API.deleteTodo(todo.id)
        .then(()=>{
        this.props.store.dispatch(removeTodoAction(todo.id));
    })
};
```

이제 디스패치를 호출하는 대신 데이터베이스에서 항목을 삭제하고, 아이템이 삭제되었다는 확인을 받으면 dispatch를 호출한다.



잘 작동하지만 사용자가 항목을 제거했을 때 즉각적인 피드백을 받으면 좋을 것이다. 우리가 사용할 것은 optimistic updates라는 작은 기술이다. 기본적으로 우리가 하고 싶은 것은 진짜 삭제될 때까지 기다리지 않는 것이다. dispatch를 호출하기 전에 데이터베이스에서 바로 항목이 삭제되었다는 확인 메시지가 나타나도록 하고 싶다.

- API를 요청하기 전에 먼저 dispatch 호출해 기본적으로 항목을 제거한다.

- 만약 문제가 있다면 다시 항목을 추가하고 오류가 발생했음을 알린다.

```react
removeItem = todo => {
    this.props.store.dispatch(removeTodoAction(todo.id));

    return API.deleteTodo(todo.id)
        .catch(()=>{
            this.props.store.dispatch(addTodoAction(todo))
            alert('Error')
    })
};
```



goal에도 동일한 작업을 진행해준다.

```react
removeItem = todo => {
    this.props.store.dispatch(removeGoalAction(goal.id));

    return API.deleteGoal(goal.id)
        .catch(()=>{
        this.props.store.dispatch(addGoalAction(goal))
        alert('Error')
    })
};
```

이렇게 할 일 목록이나 목표에서 항목을 제거할 때마다, 사용자는 이에 대한 즉각적인 피드백을 받을 뿐만아니라 가짜 데이터베이스를 업데이트하고 있다.



이제 toggle도 적용해주자. (goal도 유사하게 적용해주면된다.)

```react
toggleItem = id => {
    this.props.store.dispatch(toggleTodoAction(id));

    return API.saveTodoToggle(id)
        .catch(()=>{
        this.props.store.dispatch(toggleGoalAction(goal))
        alert('Error')
    })
};
```

[전체코드 참고](https://github.com/udacity/reactnd-redux-todos-goals/commit/89a31404efd2482256e4ce4fbf698fee4afda100)



### Summary

이 섹션에서는 더 많은 기능을 API 사용으로 교체했습니다. 이제 데이터베이스를 사용하여 다음을 수행합니다.

- 할 일과 목표를 제거
- 할 일의 상태를 토글
- 새로운 할 일 또는 목표를 저장

중요한 것은 제거 및 토글을 위해 이러한 작업을 낙관적으로 수행한다는 것입니다. 따라서 변경 사항이 서버에서 올바르게 성공한다고 가정하므로 UI를 즉시 업데이트 한 다음 API가 오류를 반환하는 경우에만 원래 상태로 롤백합니다. 낙관적 업데이트는 사용자에게보다 사실적이고 역동적 인 경험을 제공하기 때문에 더 좋습니다.